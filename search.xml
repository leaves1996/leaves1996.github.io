<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[第1-2节：基础数据类型和包装类]]></title>
    <url>%2F2019%2F08%2F16%2F1-2%E8%8A%82-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[基本数据类型 Java 基础数据按类型可以分为四大类：布尔型、整数型、浮点型、字符型，这四大类包含 8 种基础数据类型。 布尔型：boolean 整数型：byte、short、int、long 浮点型：float、double 字符型：char 八种基础类型取值如下： 数据类型 代表含义 默认值 取值 包装类 byte 字节型 (byte)0 -128 到 127 Byte short 短整数型 (short)0 -2^15 到 2^15-1 Short int 整数型 0 -2^31 到 2^31-1 Integer long 长整数型 0L -2^63 到 2^63-1 Long float 单浮点型 0.0f 1.4e-45 到 3.4e+38 Float double 双浮点型 0.0d 4.9e-324 到 1.798e+308 Double boolean 布尔型 false 0(false) 到 1(true) Boolean char 字符型 ‘\u0000’(空) ‘\u0000’ 到 ‘\uFFFF’ Character &emsp;&emsp;除 char 的包装类 Character 和 int 的包装类 Integer 之外，其他基础数据类型的包装类只需要首字母大写即可。包装类的作用和特点，本文下半部分详细讲解。 &emsp;&emsp;我们可以在代码中，查看某种类型的取值范围，代码如下： 123456public static void main(String[] args) &#123; // Byte 取值：-128 ~ 127 System.out.println(String.format("Byte 取值：%d ~ %d", Byte.MIN_VALUE, Byte.MAX_VALUE)); // Int 取值：-2147483648 ~ 2147483647 System.out.println(String.format("Int 取值：%d ~ %d", Integer.MIN_VALUE, Integer.MAX_VALUE));&#125; 包装类型&emsp;&emsp;我们知道 8 种基本数据类型都有其对应的包装类，因为 Java 的设计思想是万物既对象，有很多时候我们需要以对象的形式操作某项功能，比如说获取哈希值（hashCode）或获取类（getClass）等。 &emsp;&emsp;那包装类特性有哪些？ 功能丰富 &emsp;&emsp;包装类本质上是一个对象，对象就包含有属性和方法，比如 hashCode、getClass 、max、min 等。 可定义泛型类型参数 &emsp;&emsp;包装类可以定义泛型，而基础类型不行。 &emsp;&emsp;比如使用 Integer 定义泛型，代码：List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); 如果使用 int 定义就会报错，代码： 1List list = new ArrayList&lt;&gt;(); // 编译器代码报错 序列化 &emsp;&emsp;因为包装类都实现了 Serializable 接口，所以包装类天然支持序列化和反序列化。比如 Integer 的类图如下： 类型转换 &emsp;&emsp;包装类提供了类型转换的方法，可以很方便的实现类型之间的转换，比如 Integer 类型转换代码： 1234String age = "18";int ageInt = Integer.parseInt(age) + 2;// 输出结果：20System.out.println(ageInt); 高频区间的数据缓存 &emsp;&emsp;此特性为包装类很重要的用途之一，用于高频区间的数据缓存，以 Integer 为例来说，在数值区间为 -128~127 时，会直接复用已有对象，在这区间之外的数字才会在堆上产生。 我们使用 == 对 Integer 进行验证，代码如下： 1234567891011public static void main(String[] args) &#123; // Integer 高频区缓存范围 -128~127 Integer num1 = 127; Integer num2 = 127; // Integer 取值 127 == 结果为 true（值127 num1==num2 =&gt; true） System.out.println("值127 num1==num2 =&gt; " + (num1 == num2)); Integer num3 = 128; Integer num4 = 128; // Integer 取值 128 == 结果为 false（值128 num3==num4 =&gt; false） System.out.println("值128 num3==num4 =&gt; " + (num3 == num4));&#125; &emsp;&emsp;从上面的代码很明显可以看出，Integer 为 127 时复用了已有对象，当值为 128 时，重新在堆上生成了新对象。 &emsp;&emsp;为什么会产生高频区域数据缓存？我们查看源码就能发现“线索”，源码版本 JDK8，源码如下： 12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; &emsp;&emsp;由此可见，高频区域的数值会直接使用已有对象，非高频区域的数值会重新 new 一个新的对象。 各包装类高频区域的取值范围： Boolean：使用静态 final 定义，就会返回静态值； Byte：缓存区 -128~127，全部缓存； Short：缓存区 -128~127，部分缓存； Character：缓存区 0~127，部分缓存； Long：缓存区 -128~127，部分缓存； Integer：缓存区 -128~127，部分缓存。 包装类的注意事项 int 的默认值是 0，而 Integer 的默认值是 null。 推荐所有包装类对象之间的值比较使用 equlas() 方法，因为包装类的非高频区数据会在堆上产生，而高频区又会复用已有对象，这样会导致同样的代码，因为取值的不同，而产生两种截然不同的结果。代码示例： 12345678910111213public static void main(String[] args) &#123; // Integer 高频区缓存范围 -128~127 Integer num1 = 127; Integer num2 = 127; // Integer 取值 127 == 结果为 true（值127 num1==num2 =&gt; true） System.out.println("值127 num1==num2 =&gt; " + (num1 == num2)); Integer num3 = 128; Integer num4 = 128; // Integer 取值 128 == 结果为 false（值128 num3==num4 =&gt; false） System.out.println("值128 num3==num4 =&gt; " + (num3 == num4)); // Integer 取值 128 equals 结果为 true（值128 num3.equals(num4) =&gt; true） System.out.println("值128 num3.equals(num4) =&gt; " + num3.equals(num4));&#125; Float 和 Double 不会有缓存，其他包装类都有缓存。 Integer 是唯一一个可以修改缓存范围的包装类，在 VM optons 加入参数： 1-XX:AutoBoxCacheMax=666 即修改缓存最大值为 666 。 示例代码如下： 1234567891011public static void main(String[] args) &#123; Integer num1 = -128; Integer num2 = -128; System.out.println("值为-128 =&gt; " + (num1 == num2)); Integer num3 = 666; Integer num4 = 666; System.out.println("值为666 =&gt; " + (num3 == num4)); Integer num5 = 667; Integer num6 = 667; System.out.println("值为667 =&gt; " + (num5 == num6));&#125; 执行结果如下： 1234值为-128 =&gt; true值为666 =&gt; true值为667 =&gt; false由此可见将 Integer 最大缓存修改为 666 之后，667 不会被缓存，而 -128~666 之间的数都被缓存了。 相关面试题 以下 Integer 代码输出的结果是？12345Integer age = 10;Integer age2 = 10;Integer age3 = 133;Integer age4 = 133;System.out.println((age == age2) + "," + (age3 == age4)); 答：true,false 以下 Double 代码输出的结果是？12345Double num = 10d;Double num2 = 10d;Double num3 = 133d;Double num4 = 133d;System.out.println((num == num2) + "," + (num3 == num4)); 答：false,false 以下程序输出结果是？1234int i = 100;Integer j = new Integer(100);System.out.println(i == j);System.out.println(j.equals(i)); A：true,trueB：true,falseC：false,trueD：false,false 答：A &emsp;&emsp;题目分析：有人认为这和 Integer 高速缓存有关系，但你发现把值改为 10000 结果也是 true,true，这是因为 Integer 和 int 比较时，会自动拆箱为 int 相当于两个 int 比较，值一定是 true,true。 以下程序执行的结果是？12final int iMax = Integer.MAX_VALUE;System.out.println(iMax + 1); A：2147483648B：-2147483648C：程序报错D：以上都不是 答：B &emsp;&emsp;题目解析：这是因为整数在内存中使用的是补码的形式表示，最高位是符号位 0 表示正数，1 表示负数，当执行 +1 时，最高位就变成了 1，结果就成了 -2147483648。 以下程序执行的结果是？123456Set&lt;Short&gt; set = new HashSet&lt;&gt;();for (short i = 0; i &lt; 5; i++) &#123; set.add(i); set.remove(i - 1);&#125;System.out.println(set.size()); A：1B：0C：5D：以上都不是 答：5 &emsp;&emsp;题目解析：Short 类型 -1 之后转换成了 Int 类型，remove() 的时候在集合中找不到 Int 类型的数据，所以就没有删除任何元素，执行的结果就是 5。 short s=2;s=s+1; 会报错吗？short s=2;s+=1; 会报错吗？ &emsp;&emsp;答：s=s+1 会报错，s+=1 不会报错，因为 s=s+1 会导致 short 类型升级为 int 类型，所以会报错，而 s+=1 还是原来的 short 类型，所以不会报错。 float f=3.4; 会报错吗？为什么？ &emsp;&emsp;答：会报错，因为值 3.4 是 double 类型，float 类型级别小于 double 类型，所以会报错。如下图所示： 为什么需要包装类？ &emsp;&emsp;答：需要包装类的原因有两个。 ① Java 的设计思想是万物既对象，包装类体现了面向对象的设计理念； ② 包装类包含了很多属性和方法，比基础数据类型功能多，比如提供的获取哈希值（hashCode）或获取类（getClass）的方法等。 基础类 int 和包装类 Integer，在 -128~127 之间都会复用已有的缓存对象，这种说法正确吗？ &emsp;&emsp;答：不正确，只有包装类高频区域数据才有缓存。 包装类 Double 和 Integer 一样都有高频区域数据缓存，这种说法正确吗？ &emsp;&emsp;答：不正确，基础数据类型的包装类只有 Double 和 Float 没有高频区域的缓存。 包装类的值比较要使用什么方法？ &emsp;&emsp;答：包装类因为有高频区域数据缓存，所以推荐使用 equals() 方法进行值比较。 包装类有哪些功能？ &emsp;&emsp;答：包装类提供的功能有以下几个。 功能丰富：包装类包含了有 hashCode、getClass 、max、min 等方法； 可定义泛型类型参数：例如 List list = new ArrayList&lt;&gt;(); 序列化：包装类实现了 Serializable 接口，所以包装类天然支持序列化和反序列化； 类型转换：包装类提供了方便的类型转换方法，比如 Integer 的 parseInt() 方法； 高频区域数据缓存：高频区域可使用已有的缓存对象。 详见正文“包装类型”部分内容。 泛型可以为基础类型吗？为什么？ &emsp;&emsp;答：泛型不能使用基础数据类型。泛型在 JVM（Java虚拟机）编译的时候会类型檫除，比如代码 List list 在 JVM 编译的时候会转换为 List list ，因为泛型是在 JDK 5 时提供的，而 JVM 的类型檫除是为了兼容以前代码的一个折中方案，类型檫除之后就变成了 Object，而 Object 不能存储基础数据类型，但可以使用基础数据类型对应的包装类，所以像 List list 这样的代码是不被允许的，编译器阶段会检查报错，而 List list 是被允许的。 选择包装类还是基础类的原则有哪些？ &emsp;&emsp;答：我们知道正确的使用包装类，可以提供程序的执行效率，可以使用已有的缓存，一般情况下选择基本数据类型还是包装类原则有以下几个。 ① 所有 POJO 类属性必须使用包装类； ② RPC 方法返回值和参数必须使用包装类； ③ 所有局部变量推荐使用基础数据类型。 基础数据类型在 JVM 中一定存储在栈中吗？为什么？ &emsp;&emsp;答：基础数据类型不一定存储在栈中，因为基础类型的存储位置取决于声明的作用域，来看具体的解释。 当基础数据类型为局部变量的时候，比如在方法中声明的变量，则存放在方法栈中的，当方法结束系统会释放方法栈，在该方法中的变量也会随着栈的销毁而结束，这也是局部变量只能在方法中使用的原因； 当基础数据类型为全局变量的时候，比如类中的声明的变量，则存储在堆上，因为全局变量不会随着某个方法的执行结束而销毁。 以下程序执行的结果是？ 1234567Integer i1 = new Integer(10);Integer i2 = new Integer(10);Integer i3 = Integer.valueOf(10);Integer i4 = Integer.valueOf(10);System.out.println(i1 == i2);System.out.println(i2 == i3);System.out.println(i3 == i4); A：false,false,falseB：false,false,trueC：false,true,trueD：true,false,false 答：B &emsp;&emsp;题目解析：new Integer(10) 每次都会创建一个新对象，Integer.valueOf(10) 则会使用缓存池中的对象。 3*0.1==0.3 返回值是多少？ &emsp;&emsp;答：返回值为：false。 &emsp;&emsp;题目解析：因为有些浮点数不能完全精确的表示出来，如下代码： 12System.out.println(3 * 0.1);//返回的结果是：0.30000000000000004。]]></content>
      <categories>
        <category>Java面试全解析</category>
        <category>第一部分：Java基础强化</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>Java面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第 1-1 节：Java 程序是如何执行的？]]></title>
    <url>%2F2019%2F08%2F15%2F1-1%E8%8A%82-Java%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84%2F</url>
    <content type="text"><![CDATA[Java 介绍&emsp;&emsp;Java 诞生于 1991 年，Java 的前身叫做 Oak（橡树），但在注册商标的时候，发现这个名字已经被人注册了，后来团队的人就在咖啡馆讨论这件事该怎么办，有人灵机一动说叫 Java 如何，因为当时他们正在喝着一款叫做 Java 的咖啡。就这样，这个后来家喻户晓的名字，竟以这种“随意”的方式诞生了，并一直沿用至今。 Java 发展历程： 1990，Sun 成立了“Green Team”项目小组 1991，Java 语言前身 Oak（橡树）诞生 1995，Oak 语言更名为 Java 1996，Java 1.0 发布 1997，Java 1.1 发布 1998，Java 1.2 发布 2000，Java 1.3 发布 2000，Java 1.4 发布 2004，Java 5 发布 2006，Java 6 发布 2011，Java 7 发布 2014，Java 8 发布 2017，Java 9（非长期支持版）发布 2018.03，Java 10（非长期支持版） 发布 2018.09，Java 11（长期支持版）发布 2019.03, Java 12（非长期支持版） 发布注：长期支持版指的是官方发布版本后的一段时间内，通常以“年”为计数单位，会对此版本进行持续维护和升级。 版本发布时间 Java 10 之后，官方表示每半年推出一个大版本，长期支持版本（LTS）每三年发布一次。 Java 和 JDK 的关系&emsp;&emsp;JDK（Java Development Kit）Java 开发工具包，它包括：编译器、Java 运行环境（JRE，Java Runtime Environment）、JVM（Java 虚拟机）监控和诊断工具等，而 Java 则表示一种开发语言。 Java 程序是怎么执行的？&emsp;&emsp;我们日常的工作中都使用开发工具（IntelliJ IDEA 或 Eclipse 等）可以很方便的调试程序，或者是通过打包工具把项目打包成 jar 包或者 war 包，放入 Tomcat 等 Web 容器中就可以正常运行了，但你有没有想过 Java 程序内部是如何执行的？ &emsp;&emsp;其实不论是在开发工具中运行还是在 Tomcat 中运行，Java 程序的执行流程基本都是相同的，它的执行流程如下： 先把 Java 代码编译成字节码，也就是把 .java 类型的文件编译成 .class 类型的文件。这个过程的大致执行流程：Java 源代码 -&gt; 词法分析器 -&gt; 语法分析器 -&gt; 语义分析器 -&gt; 字符码生成器 -&gt; 最终生成字节码，其中任何一个节点执行失败就会造成编译失败； 把 class 文件放置到 Java 虚拟机，这个虚拟机通常指的是 Oracle 官方自带的 Hotspot JVM； Java 虚拟机使用类加载器（Class Loader）装载 class 文件； 类加载完成之后，会进行字节码效验，字节码效验通过之后 JVM 解释器会把字节码翻译成机器码交由操作系统执行。但不是所有代码都是解释执行的，JVM 对此做了优化，比如，以 Hotspot 虚拟机来说，它本身提供了 JIT（Just In Time）也就是我们通常所说的动态编译器，它能够在运行时将热点代码编译为机器码，这个时候字节码就变成了编译执行。 Java 程序执行流程图如下： Java 虚拟机是如何判定热点代码的？ Java 虚拟机判定热点代码的方式有两种： 基于采样的热点判定&emsp;&emsp;主要是虚拟机会周期性的检查各个线程的栈顶，若某个或某些方法经常出现在栈顶，那这个方法就是“热点方法”。这种判定方式的优点是实现简单；缺点是很难精确一个方法的热度，容易受到线程阻塞或外界因素的影响。 基于计数器的热点判定&emsp;&emsp;主要就是虚拟机给每一个方法甚至代码块建立了一个计数器，统计方法的执行次数，超过一定的阀值则标记为此方法为热点方法。&emsp;&emsp;Hotspot 虚拟机使用的基于计数器的热点探测方法。它使用了两类计数器：方法调用计数器和回边计数器，当到达一定的阀值是就会触发 JIT 编译。&emsp;&emsp;方法调用计数器：在 client 模式下的阀值是 1500 次，Server 是 10000 次，可以通过虚拟机参数： -XX:CompileThreshold=N 对其进行设置。但是JVM还存在热度衰减，时间段内调用方法的次数较少，计数器就减小。&emsp;&emsp;回边计数器：主要统计的是方法中循环体代码执行的次数。&emsp;&emsp;由上面的知识我们可以看出，要想做到对 Java 了如之中，必须要好好学习 Java 虚拟机，那除了 Java 虚拟机外，还有哪些知识是面试必考，也是 Java 工程师必须掌握的知识呢？ Java 基础中的核心内容 &emsp;&emsp;字符串和字符串常量池的深入理解、Array 的操作和排序算法、深克隆和浅克隆、各种 IO 操作、反射和动态代理（JDK 自身动态代理和 CGLIB）等。 集合 &emsp;&emsp;集合和 String 是编程中最常用的数据类型，关于集合的知识也是面试备考的内容，它包含：链表（LinkedList）、TreeSet、栈（Stack）、队列（双端、阻塞、非阻塞队列、延迟队列）、HashMap、TreeMap 等，它们的使用和底层存储数据结构都是热门的面试内容。 多线程 &emsp;&emsp;多线程使用和线程安全的知识也是必考的面试题目，它包括：死锁、6 种线程池的使用与差异、ThreadLocal、synchronized、Lock、JUC（java.util.concurrent包）、CAS（Compare and Swap）、ABA 问题等。 热门框架 &emsp;&emsp;Spring、Spring MVC、MyBatis、SpringBoot 分布式编程 &emsp;&emsp;消息队列（RabbitMQ、Kafka）、Dubbo、Zookeeper、SpringCloud 等。 数据库 &emsp;&emsp;MySQL 常用引擎的掌握、MySQL 前缀索引、回表查询、数据存储结构、最左匹配原则、MySQL 的问题分析和排除方案、MySQL 读写分离的实现原理以及 MySQL 的常见优化方案等。 Redis 的使用场景、缓存雪崩和缓存穿透的解决方案、Redis 过期淘汰策略和主从复制的实现方案等。 Java 虚拟机 &emsp;&emsp;虚拟机的组成、垃圾回收算法、各种垃圾回收器的区别、Java 虚拟机分析工具的掌握、垃圾回收器的常用调优参数等。 其他 &emsp;&emsp;常用算法的掌握、设计模式的理解、网络知识和常见 Linux 命令的掌握等。 相关面试题 Java 语言都有哪些特点？ 答：Java 语言包含以下特点。 面向对象，程序容易理解、开发简单、方便； 跨平台，可运行在不同服务器类型上，比如：Linux、Windows、Mac 等； 执行性能好，运行效率高； 提供大量的 API 扩展，语言强大； 有多线程支持，增加了响应和实时交互的能力； 安全性好，自带验证机制，确保程序的可靠性和安全性。 Java 跨平台实现的原理是什么？ 答：要了解 Java 跨平台实现原理之前，必须先要了解 Java 的执行过程，Java 的执行过程如下： &emsp;&emsp;Java 执行流程：Java 源代码（.java）-&gt; 编译 -&gt; Java 字节码（.class） -&gt;通过 JVM（Java 虚拟机）运行 Java 程序。每种类型的服务器都会运行一个 JVM，Java 程序只需要生成 JVM 可以执行的代码即可，JVM 底层屏蔽了不同服务器类型之间的差异，从而可以在不同类型的服务器上运行一套 Java 程序。 JDK、JRE、JVM 有哪些区别？ 答：了解了 JDK、JRE、JVM 的定义也就明白了它们之间的区别，如下所述。 JDK：Java Development Kit（Java 开发工具包）的简称，提供了 Java 的开发环境和运行环境； JRE：Java Runtime Environment（Java 运行环境）的简称，为 Java 的运行提供了所需环境； JVM：Java Virtual Machine（Java虚拟机）的简称，是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的，简单来说就是所有的 Java 程序都是运行在 JVM（Java 虚拟机）上的。 &emsp;&emsp;总体来说，JDK 提供了一整套的 Java 运行和开发环境，通常使用对象为 Java 的开发者，当然 JDK 也包含了 JRE；而 JRE 为 Java 运行的最小运行单元，一般安装在 Java 服务器上，所以 JDK 和 JRE 可以从用途上进行理解和区分。JVM 不同于 JDK 和 JRE，JVM 是 Java 程序运行的载体，Java 程序只有通过 JVM 才能正常的运行。 Java 中如何获取明天此刻的时间？ 答：JDK 8 之前使用 Calendar.add() 方法获取，代码如下： 123Calendar calendar = Calendar.getInstance();calendar.add(Calendar.DATE, 1);System.out.println(calendar.getTime()); JDK 8 有两种获取明天时间的方法。 方法一，使用 LocalDateTime.plusDays() 方法获取，代码如下： 123LocalDateTime today = LocalDateTime.now();LocalDateTime tomorrow = today.plusDays(1);System.out.println(tomorrow); 方法二，使用 LocalDateTime.minusDays() 方法获取，代码如下： 123LocalDateTime today = LocalDateTime.now();LocalDateTime tomorrow = today.minusDays(-1);System.out.println(tomorrow); minusDays() 方法为当前时间减去 n 天，传负值就相当于当前时间加 n 天。 Java 中如何跳出多重嵌套循环？ 答：Java 中跳出多重嵌套循环的两种方式。 方法一：定义一个标号，使用 break 加标号的方式 方法二：使用全局变量终止循环 方法一，示例代码： 123456789myfor:for (int i = 0; i &lt; 100; i++) &#123; for (int j = 0; j &lt; 100; j++) &#123; System.out.println("J:" + j); if (j == 10) &#123; // 跳出多重循环 break myfor; &#125; &#125;&#125; 方法二，示例代码： 1234567891011boolean flag = true;for (int i = 0; i &lt; 100 &amp;&amp; flag; i++) &#123; for (int j = 0; j &lt; 100; j++) &#123; System.out.println("J:" + j); if (j == 10) &#123; // 跳出多重循环 flag = false; break; &#125; &#125;&#125; char 变量能不能存贮一个中文汉字？为什么？ 答：char 变量可以存贮一个汉字，因为 Java 中使用的默认编码是 Unicode ，一个 char 类型占 2 个字节（16 byte），所以放一个中文是没问题的。 Java 中会存在内存泄漏吗？请简单描述一下。 答：一个不再被程序使用的对象或变量一直被占据在内存中就造成了内存泄漏。 Java 中的内存泄漏的常见情景如下： 长生命周期对象持有短生命的引用，比如，缓存系统，我们加载了一个对象放在缓存中，然后一直不使用这个缓存，由于缓存的对象一直被缓存引用得不到释放，就造成了内存泄漏； 各种连接未调用关闭方法，比如，数据库 Connection 连接，未显性地关闭，就会造成内存泄漏； 内部类持有外部类，如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露； 改变哈希值，当一个对象被存储进 HashSet 集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则对象修改后的哈希值与最初存储进 HashSet 集合中时的哈希值就不同了，在这种情况下，即使在 contains 方法使用该对象的当前引用作为的参数去 HashSet 集合中检索对象，也将返回找不到对象的结果，这也会导致无法从 HashSet 集合中单独删除当前对象，造成内存泄露。]]></content>
      <categories>
        <category>Java面试全解析</category>
        <category>第一部分：Java基础强化</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>Java面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面试全解析大纲]]></title>
    <url>%2F2019%2F08%2F15%2FJava%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90%E5%A4%A7%E7%BA%B2%2F</url>
    <content type="text"><![CDATA[本系Java面试全解析内容主要分为七大部分 共计 37 篇文章，约 10 万字。 &emsp;&emsp;后续文章小编会有几篇试看文章，然后后续的文章会有密码，如有需要大家可以根据本文下方的图片中的二维码进行购买。或者发邮件: loye_you@163.com 联系小编给密码。本系博客，小编只是搬运工。 第一部分：Java 基础强化&emsp;&emsp;这部分包含 7 篇文章，我会从 Java 最基础的内容讲起。有最常见的 String 面试题从表象到原理的深入讲解；还有 Java 8 中新特性的介绍，比如时间和日期模块，让你使用更简洁和优化的方式写出更完美的代码；还有我们日常用的很多包装类不为人知的有趣现象和知识盲点介绍；还有数组以及算法的介绍，虽然基础但容易被面试者忽略和容易出错的问题…… 第二部分：各种类和克隆&emsp;&emsp;这部分包含 4 篇文章，除了会深入讲解 Java 中的各种类和接口的相关内容，还会深入讲解浅克隆和深克隆的各种实现方式，以及配合各种图片让你更形象地理解深/浅克隆的本质。 第三部分：数据结构和队列&emsp;&emsp;这部分包含 4 篇文章，对面试中必考的集合，除了相关的面试题讲解，更要理清各种集合之间的关系，创建集合之间的联系，这样才能对集合的整体理解做到心中有数。我使用了归纳法和各种关系图，帮你理清思路，打通你的“任督二脉”。其中还有队列的内容，可能开发者经常会听到，但实际的工作中使用的较少，本部分内容也会带你玩转这些数据结构，让你在面试中能够应对自如。 第四部分：反射和动态代理&emsp;&emsp;这部分会帮你理清反射和动态代理的关系，并提供很多实际使用的场景，让你更好地使用到反射和动态代理，当然这部分也会为你提供各种形式反射和动态代理的实现方式，让你可以随心所欲的使用它们。这部分内容还提供了 IO 的相关知识，并提供详细的示例和原理分析，也会试着编写一个简单 Socket 服务器。 第五部分：多线程编程&emsp;&emsp;这部分包含 7 篇文章，讲述了包含 Java 8 在内的 8 种线程池，以及线程池的正确使用姿势，还有死锁代码的编写和死锁的解决方案。本部分还会介绍 Java 中的各种锁，以及它们的区别和使用场景，还会介绍 CAS 和著名的 ABA 问题的解决方案，还有多线程中的各种高频面试题。 第六部分：Java 热门框架和分布式消息队列&emsp;&emsp;这部分包含 6 篇文章，从 Spring 到最近比较热门的微服务框架 SpringBoot，还有国内常用的 Mybatis 和 Java 技术栈中其他常用的框架，比如 Double 和 Zookeeper，还有分布式消息队列 RabbitMQ 和 Kafka 的介绍和面试题汇总。 第七部分：Java 高手进阶&emsp;&emsp;本部分内容包含 6 篇文章，可谓 Java 技术栈最实用的面试补充“大礼包”，有设计模式的面试题汇总；还有 DBA 级别的 MySQL 和 Redis 面试题汇总；还有成为高手必懂的 JVM 和算法的面试题汇总；最后回到本课程的主题内容，提供了 Java 最容易出错的面试题汇总作为收束篇目，助你稳健地拿到想要的 Offer。 该系课程获取方式：]]></content>
      <categories>
        <category>Java面试全解析</category>
        <category>前言：Java面试全解析大纲</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>Java面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础之线程总结]]></title>
    <url>%2F2019%2F08%2F14%2FJava%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[什么是线程？&emsp;&emsp;线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位，可以使用多线程对进行运算提速。 比如，如果一个线程完成一个任务要100毫秒，那么用十个线程完成改任务只需10毫秒 进程和线程的区别 进程是程序运行和资源分配的基本单位 一个程序至少有一个进程,一个进程至少有一个线程 一个进程下也可以有多个线程来增加程序的执行速度 进程在执行过程中拥有独立的内存单元,而多个线程共享内存资源,减少切换次数,从而效率更高 线程是进程的一个实体,是cpu调度和分派的基本单位,是比程序更小的能独立运行的基本单位 同一进程中的多个线程之间可以并发执行 并行和并发有什么区别？&emsp;&emsp;并行： 多个处理器或者多核处理器同时处理多个任务。&emsp;&emsp;并发： 多个任务在同一个 CPU 核上，按细分的时间片轮流（交替）执行，从逻辑上来看那些任务是同时执行。 请看下图：并发 = 两个队列和一台咖啡机。并行 = 两个队列和两个咖啡机。 守护线程是什么？&emsp;&emsp;守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或者等待处理某些发生的事件。在 Java 中垃圾回收线程就是特殊的守护线程。 &emsp;&emsp;一般来说，JVM(JAVA虚拟机）中一般会包括两种线程，分别是用户线程和后台线程。 所谓后台线程（daemon)线程指的是：在程序运行的时候在后台提供的一种通用的服务的线程，并且这种线程并不属于程序中不可或缺的部分。因此，当所有的非后台线程结束的时候，也就是用户线程都结束的时候，程序也就终止了。同时，会杀死进程中的所有的后台线程。 反过来说，只要有任何非后台线程还在运行，程序就不会结束。比如执行main()的就是一个非后台线程。 &emsp;&emsp;基于这个特点，当虚拟机中的用户线程全部退出运行时，守护线程没有服务的对象后，JVM也就退出了。&emsp;&emsp;所有的用户线程一定会走完，但是守护线程随着用户线程的销毁而销毁 1234boolean isDaemon() 测试这个线程是否是守护线程。 void setDaemon(boolean on) 将此线程标记为 daemon线程或用户线程。 创建线程有哪几种方式？创建线程有三种方式： 方式一：继承 Thread 重写 run 方法 方式二：实现 Runnable 接口 方式三：实现 Callable 接口 创建线程方式一和方式二的比较 1、代码复杂程度： 继承Thread方式简单。 实现Runnable接口的方式比较复杂。 2、实现原理： 继承方式：调用 start 方法，调用 start0 方法，start0 是本地方法 private native void start0(); ,由虚拟机实现，是C语言实现的方法，所以在java中看不到源码。本地方法 start0 返回来调用java中的run方法，run方法已经在子类中重写过了，所以最终运行的是子类重写了的run方法。 实现方式：构造器中，将Runnable的实现类对象传入构造器中，经过一路init 方法的传递，最终，用于给Thread 类型中的某个成员变量（target）赋值；调用对象的start方法，最终也是返回来调用Thread 类中的run方法，判断当前的成员变量target是否为null，如果不为null，就调用target的run方法，而这个run方法我们已经重写了，最终执行的是我们重写的run方法。 使用匿名内部类开启线程&emsp;&emsp;如果我们同时实现 Runnable接口，并且继承Thread并重写run方法，该线程会以那种方式为主？两种方式都存在则以继承Thread类为主。请看如下代码： 1234567891011new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println("实现Runnable接口并重写run方法。。。。。。"); &#125;&#125;)&#123; @Override public void run() &#123; System.out.println("Thread类的匿名内部类子类，重写run方法。。。。。"); &#125;&#125;.start(); 执行结果： 1Thread类的匿名内部类子类，重写run方法。。。。。 Runnable 和 Callable 有什么区别？ Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已； Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。 Thread类中的start()和run()方法有什么区别? start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。 run() 方法用于执行线程的运行时代码。如果对象调用run() 方法，是普通方法色调用，并非线程的启动。 run() 可以重复调用。而 start() 只能调用一次，如果再次调用会抛异常。 java中用到的线程调度算法是什么抢占式调度模型&emsp;&emsp;优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些。 设置和获取线程的优先级 12public final int getPriority()public final void setPriority(int newPriority) 线程优先级： 123主线程的优先级:5线程的优先级是1-10默认线程都是5 如果设置优先级传入的参数不合法则会抛出如下异常： 1234java.lang.IllegalArgumentException异常名称: 非法参数异常产生原因: 参数不合法解决办法: 如果是线程说明线程的优先级不在指定范围内 什么是线程安全和线程不安全？通俗的说：加锁的就是是线程安全的，不加锁的就是是线程不安全的 线程安全线程安全: 就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问，直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。 线程不安全线程不安全：就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据。 java中的++操作符线程安全么?不是线程安全的操作。它涉及到多个指令，如读取变量值，增加，然后存储回内存，这个过程可能会出现多个线程交差 线程有哪些状态？线程的状态： NEW 尚未启动 RUNNABLE 正在执行中 BLOCKED 阻塞的 （被同步锁或者IO锁阻塞） WAITING 永久等待状态 TIMED_WAITING 等待指定的时间重新被唤醒的状态 TERMINATED 执行完成 什么情况下导致线程阻塞？&emsp;&emsp;阻塞指的是暂停一个线程的执行以等待某个条件发生（如某资源就绪），学过操作系统的同学对它一定已经很熟悉了。Java 提供了大量方法来支持阻塞，下面让我们逐一分析。 sleep() &emsp;&emsp;sleep() 允许 指定以毫秒为单位的一段时间作为参数，它使得线程在指定的时间内进入阻塞状态，不能得到CPU 时间，指定的时间一过，线程重新进入可执行状态。 &emsp;&emsp;典型地，sleep() 被用在等待某个资源就绪的情形：测试发现条件不满足后，让线程阻塞一段时间后重新测试，直到条件满足为止 suspend() 和 resume() &emsp;&emsp;两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应d的resume() 被调用，才能使得线程重新进入可执行状态。 &emsp;&emsp;典型地，suspend() 和 resume() 被用在等待另一个线程产生的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用 resume() 使其恢复。 yield() &emsp;&emsp;yield() 使当前线程放弃当前已经分得的CPU 时间，但不使当前线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。 &emsp;&emsp;调用 yield() 的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程 wait() 和 notify() &emsp;&emsp;两个方法配套使用，wait() 使得线程进入阻塞状态，它有两种形式，一种允许 指定以毫秒为单位的一段时间作为参数，另一种没有参数，前者当对应的 notify() 被调用或者超出指定时间时线程重新进入可执行状态，后者则必须对应的 notify() 被调用. sleep() 和 wait() 有什么区别 所在的类不同：sleep() 来自 Thread，wait() 来自 Object。调用sleep()方法的过程中，线程不会释放对象锁。而 调用 wait 方法线程会释放对象锁 释放锁：sleep() 不释放锁；wait() 释放锁。 用法不同：sleep(milliseconds)需要指定一个睡眠时间，sleep() 时间到了会自动恢复；wait() 可以使用 notify() 、notifyAll()直接唤醒。 sleep()睡眠后不出让系统资源，wait让其他线程可以占用CPU stop和interrupt的区别 stop会直接将线程生命结束 interrupt会给对应的线程抛出一个异常，那么对应的线程可以通过InterruptedException来捕获这个异常，并且做出相应的异常处理 什么是线程加入线程加入：主要是在开启某一个线程后，立即执行该方法，那么该线程会在执行完毕后其它线程才能抢占 CPU 的使用权。 1public final void join() 优先让线程执行完毕 什么是线程礼让线程礼让: 暂时让出CPU的执行权一小会，之后依然和其它线程抢占 CPU 的使用权。 1public static void yield() 暂时让出CPU的执行权一小会 线程同步线程同步：保证同一资源同步共享。同步方式：方式一：同步代码块 12格式:synchronized(同步锁对象) &#123;&#125; 方式二：同步方法 1234格式:访问权限修饰符 synchronized 返回值类型 方法名(参数列表) throws 异常类 &#123; return 返回值;&#125; 注意:a.锁必须是同一把锁b.锁对象可以是任意对象c.如果是同步方法，那么锁对象是this,当前对象作锁 方式三：利用Lock锁void lock() 获取锁。void unlock() 试图释放此锁。 notify() 和 notifyAll() 有什么区别 notifyAll() 会唤醒所有的线程，notify() 只会唤醒一个线程。 notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify() 只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。 产生死锁的条件 1.互斥条件：一个资源每次只能被一个进程使用。 2.请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 3.不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。 4.循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。 为什么wait,nofity和nofityAll这些方法不放在Thread类当中&emsp;&emsp;一个很明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。 怎么唤醒一个阻塞的线程 如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它； 如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。 什么是Executors框架？Executor框架同java.util.concurrent.Executor 接口在Java 5中被引入。 Executor框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架。 无限制的创建线程会引起应用程序内存溢出。所以创建一个线程池是个更好的的解决方案，因为可以限制线程的数量并且可以回收再利用这些线程。 利用Executors框架可以非常方便的创建一个线程池. 创建线程池有哪几种方式？ 创建线程池的方式有七种，其中最核心的是最后一种： newSingleThreadExecutor() ： 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目。 newCachedThreadPool() ：它是一种用来处理大量短时间工作任务的线程池，具有如下几个鲜明的特点：&emsp;&emsp;1、它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；&emsp;&emsp;2、如果线程闲置的时间超过 60 秒，则被终止并移出缓存；&emsp;&emsp;3、长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列。 newFixedThreadPool() ：重用指定数目（nThreads） 的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads。 newSingleThreadScheduledExecutor() ：创建单线程池，返回ScheduledExecutorService,可以进行定时或周期性的工作调度。 newScheduledThreadPool(int corePoolSize) ：创建一个定长线程池，和 newSingleThreadScheduledExecutor() 类似，创建的是个ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程。 newWorkStealingPool(int parallelism) ：这是一个经常被人忽略的线程池，Java8 才加入这个创建方法，其内部会构建 ForkJoinPool，利用 Work-Stealing 算法，并进行地处理任务，不保证处理顺序。 ThreadPoolExecutor() ：是最原始的线程池创建，上面的 1-3 创建方式都是对 ThreadPoolExecutor() 的封装。 为什么要使用线程池避免频繁地创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据项目灵活地控制并发的数目。 什么是阻塞队列？JDK7提供了7个阻塞队列。（也属于并发容器） ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。 LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。 PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。 DelayQueue：一个使用优先级队列实现的无界阻塞队列。 SynchronousQueue：一个不存储元素的阻塞队列。 LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。 LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。 线程池中 submit() 和 execute() 方法有什么区别？submit() : 可以执行 Runnable 和 Callable 类型的任务。execute() ：只能执行 Runnable 类型的任务。 在 Java 程序中怎么保证多线程的运行安全？ 方法一： 使用安全类，比如 Java.util.concurrent 下的类。 方法二： 使用自动锁 synchronized。 方法三： 使用手动锁。 手动锁 Java 示例代码如下： 12345678910Lock lock = new ReentrantLock();lock.lock();try&#123; System.out.println("获取锁");&#125; catch (Exception e) &#123; //TODO: handle exception&#125; finally &#123; System.out.println("释放锁")； lock.unlock();&#125; 多线程中 synchronized 锁升级的原理是什么？&emsp;&emsp;synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，JVM让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级为重量级锁，此过程就构成了 synchronized 锁的升级。&emsp;&emsp;锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java6 之后优化synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。 什么是死锁？当线程 A 持有独占锁a，并尝试去获取独占锁 b 的同时，线程 B 持有独占锁 b ，并尝试获取独占锁 a 的情况下，就会发生 AB 两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。 死锁示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//代码示例一：public class DieLock extends Thread&#123; private boolean flag; public DieLock() &#123;&#125; public DieLock(boolean flag) &#123; this.flag = flag; &#125; @Override public void run() &#123; if (flag) &#123; // dl1进来 synchronized (MyLock.lockA) &#123; System.out.println("if 语句中 LockA锁"); // 就在输出完这句话之后被dl2抢到了资源 synchronized (MyLock.lockB) &#123; System.out.println("if 语句中 LockB锁"); &#125; &#125; &#125; else &#123; // dl走else synchronized (MyLock.lockB) &#123; System.out.println("else 语句中 lockB锁"); synchronized (MyLock.lockA) &#123; System.out.println("else 语句中 lockA锁"); &#125; &#125; &#125; &#125;&#125;/** * 创建锁对象 */class MyLock&#123; public static final Object lockA = new Object(); public static final Object lockB = new Object();&#125;/** * 测试 */public class LockDemo &#123; public static void main(String[] args) &#123; DieLock dl1 = new DieLock(true); DieLock dl2 = new DieLock(false); dl1.start(); dl2.start(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435//代码示例二：public class DeadLock &#123; private static final String A = "A"; private static final String B = "B"; public static void main(String[] args) &#123; Thread t1 = new Thread("a")&#123; @Override public void run() &#123; synchronized (A) &#123; System.out.println(Thread.currentThread().getName() + " == A"); synchronized (B) &#123; System.out.println(Thread.currentThread().getName() + " == B"); &#125; &#125; &#125; &#125;; Thread t2 = new Thread("b")&#123; @Override public void run() &#123; synchronized (B) &#123; System.out.println(Thread.currentThread().getName() + " == B"); synchronized (A) &#123; System.out.println(Thread.currentThread().getName() + " == A"); &#125; &#125; &#125; &#125;; t1.start(); t2.start(); &#125;&#125; 怎么防止死锁？ 1.尽量使用 tryLock(long timeout, TimeUnit unit) 的方法 （ReentrantLock、ReentrantReadWriteLock），设置超时时间，超时可以退出防止死锁。(Lock锁中就使用了这种方式) 2.尽量使用 Java.util.concurrent 并发类代替自己手写锁。 3.尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。 4.尽量减少同步代码块。 5.银行家算法 ThreadLocal 是什么？ 有哪些使用场景？&emsp;&emsp;ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每个线程都可以独立地改变自己的副本，而不会影响到其它线程所对应的副本。 ThreadLocal 的使用场景：1、数据库连接2、session 管理3、spring 声明式事务管理 说一下 synchronized 底层实现原理？&emsp;&emsp;synchronized 是由一对 monitorenter/monitorexit 指令实现的，monitor 对象是同步的基本实现单元。 在 Java6 之前，monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作，性能也很低。但在 Java6 的时候，Java 虚拟机 对此进行了大刀阔斧地改进，提供了三种不同的 monitor 实现，也就是常说的三种不同的锁： 偏向锁 （Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。 Java当中有哪几种锁 自旋锁: 自旋锁在JDK1.6之后就默认开启了。基于之前的观察，共享数据的锁定状态只会持续很短的时间，为了这一小段时间而去挂起和恢复线程有点浪费，所以这里就做了一个处理，让后面请求锁的那个线程在稍等一会，但是不放弃处理器的执行时间，看看持有锁的线程能否快速释放。为了让线程等待，所以需要让线程执行一个忙循环也就是自旋操作。在jdk6之后，引入了自适应的自旋锁，也就是等待的时间不再固定了，而是由上一次在同一个锁上的自旋时间及锁的拥有者状态来决定 偏向锁: 在JDK1.之后引入的一项锁优化，目的是消除数据在无竞争情况下的同步原语。进一步提升程序的运行性能。 偏向锁就是偏心的偏，意思是这个锁会偏向第一个获得他的线程，如果接下来的执行过程中，改锁没有被其他线程获取，则持有偏向锁的线程将永远不需要再进行同步。偏向锁可以提高带有同步但无竞争的程序性能，也就是说他并不一定总是对程序运行有利，如果程序中大多数的锁都是被多个不同的线程访问，那偏向模式就是多余的，在具体问题具体分析的前提下，可以考虑是否使用偏向锁。 轻量级锁: 为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，所以在Java SE1.6里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁 synchronized 和 volatile 的区别是什么？ volatile修饰的变量,jvm每次都从主内run读取,不会从工作内存读取；&emsp;而synchronized是锁住当前变量,同一时刻只有一个线程能访问当前变量；&emsp;volatile只是作用于变量,synchronized可以用在变量，方法，类，代码段中 valatile仅能实现变量修改的可见性,无法保证原子性；synchronized可以实现变量修改的可见性和原子性。 volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。 volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化。 synchronized 和 Lock 有什么区别？ 1.synchronized 是 java 内置的关键字，Lock 是个接口 2.synchronized 无法判断是否获取锁的状态，Lock 可以判断是否获取到锁. 3.synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而Lock需要手动加锁和释放锁，如果使用不当，没有 unLock() 去释放锁就会造成死锁。 4.synchronized 可重入(同一个类中两个同步方法,获取到锁后不用每次都去获取),不可中断,非公平;Lock可中断可公平. 5.synchronized 获得锁的线程阻塞,其他线程都会无限等待,Lock不会 synchronized 和 ReentrantLock 区别是什么？synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大，但是在Java6 中对synchronized 进行了非常多的改进。 1.synchronized遇到异常不catch,锁会自动释放；ReentrantLock 使用起来比较灵活，但是必须需要手动释放锁。 2.synchronized是非公平锁,ReentrantLock可以实现公平锁. 3.前者无法获取锁的状态,后者可以,tryLock()方法可以返回是否获得了锁. 4.ReentrantLock可以精确唤醒线程,Synchronized要么随机唤醒一个,要么全部唤醒. 说一下 atomic 的原理？ atomic包中的类可以实现多线程环境下的变量操作,底层是调用CPU的CAS指令来进实现线程安全的。 atomic 主要利用 CAS（Compare And Wwap）乐观锁和 volatile 和 native 方法来保证原子操作，通过自旋保证当次修改的最终修改成功，通过降低锁粒度（多段锁）增加并发性能。 CAS相对于其他锁，不会进行内核态操作，有着一些性能的提升。但同时引入自旋，当锁竞争较大的时候，自旋次数会增多。cpu资源会消耗很高。换句话说，CAS+自旋适合使用在低并发有同步数据的应用场景。 什么是CAS&emsp;&emsp;CAS，全称为Compare and Swap，即比较-替换。假设有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，才会将内存值修改为B并返回true，否则什么都不做并返回false。当然CAS一定要volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值A对某条线程来说，永远是一个不会变的值A，只要某次CAS操作失败，永远都不可能成功 ConcurrentHashMap的并发度是什么?&emsp;&emsp;ConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势，任何情况下，Hashtable能同时有两条线程获取Hashtable中的数据吗？ ConcurrentHashMap的工作原理ConcurrentHashMap在jdk 1.6和jdk 1.8实现原理是不同的：jdk 1.6： ConcurrentHashMap是线程安全的，但是与Hashtablea相比，实现线程安全的方式不同。Hashtable是通过对hash表结构进行锁定，是阻塞式的，当一个线程占有这个锁时，其他线程必须阻塞等待其释放。 ConcurrentHashMap是采用分离锁的方式，它并没有对整个hash表进行锁定，而是局部锁定，也就是说当一个线程占有这个局部锁时，不影响其他线程对hash表其他地方的访问。 具体实现:ConcurrentHashMap内部有一个Segment jdk 1.8： 在jdk 8中，ConcurrentHashMap不再使用Segment分离锁，而是采用一种乐观锁CAS算法来实现同步问题，但其底层还是“数组+链表-&gt;红黑树”的实现。 你有哪些多线程开发良好的实践? 给线程命名 最小化同步范围 优先使用volatile 尽可能使用更高层次的并发工具而非wait和notify()来实现线程通信,如BlockingQueue,Semeaphore 优先使用并发容器而非同步容器. 考虑使用线程池 线程的生命周期 新建状态：创建一个线程对象 Thread t = new Thread(); 就绪状态（可运行状态）：线程对象创建后，其它线程调用了该对象的 start() 方法。 该状态的线程位于可运行线程池中，变得可运行（具备执行资格，没有执行权），等待获取CPU的使用权。 运行状态：线程被分配到了CPU的时间片，执行程序代码。（具备执行资格，具备执行权） 阻塞状态：阻塞状态是线程因为某种原因放弃CPU的使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。 阻塞状态分三种：等待阻塞：运行的线程执行wait() 方法，JVM 会把该线程放入等待池中。同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM 会把该线程放入到锁池中。其它阻塞：运行的线程执行 sleep() 或者 join() 方法，或者发出了 IO 请求，JVM 会把该线程设置为阻塞状态。当 sleep() 状态超时，join() 等待线程终止或者超时，或者 IO 处理完毕时，线程重新转入就绪状态。 死亡状态：当 main 方法结束、线程执行完了、调用stop 方法、或者因异常退出run() 方法，该线程结束生命周期，线程对象成为垃圾对象，等待垃圾回收器回收。 如下图分析：]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>线程</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面试题总结]]></title>
    <url>%2F2019%2F08%2F13%2FJava%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[欢迎来到我的博客，输入密码阅读！ Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>Java面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>JavaSE</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合面试题锦集]]></title>
    <url>%2F2019%2F08%2F12%2F%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98%E9%94%A6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[1、Java集合框架是什么？说出一些集合框架的优点？&emsp;&emsp;每种编程语言中都有集合，最初的Java版本包含几种集合类：Vector、Stack、HashTable和Array。随着集合的广泛使用，Java1.2提出了囊括所有集合接口、实现和算法的集合框架。在保证线程安全的情况下使用泛型和并发集合类，Java已经经历了很久。它还包括在Java并发包中，阻塞接口以及它们的实现。集合框架的部分优点如下： （1）使用核心集合类降低开发成本，而非实现我们自己的集合类。 （2）随着使用经过严格测试的集合框架类，代码质量会得到提高。 （3）通过使用JDK附带的集合类，可以降低代码维护成本。 （4）复用性和可操作性。 2、集合框架中的泛型有什么优点？&emsp;&emsp;Java1.5引入了泛型，所有的集合接口和实现都大量地使用它。泛型允许我们为集合提供一个可以容纳的对象类型，因此，如果你添加其它类型的任何元素，它会在编译时报错。这避免了在运行时出现ClassCastException，因为你将会在编译时得到报错信息。泛型也使得代码整洁，我们不需要使用显式转换和instanceOf操作符。它也给运行时带来好处，因为不会产生类型检查的字节码指令。 3、Java集合框架的基础接口有哪些？&emsp;&emsp;Collection为集合层级的根接口。一个集合代表一组对象，这些对象即为它的元素。Java平台不提供这个接口任何直接的实现。 &emsp;&emsp;Set是一个不能包含重复元素的集合。这个接口对数学集合抽象进行建模，被用来代表集合，就如一副牌。 &emsp;&emsp;List是一个有序集合，可以包含重复元素。你可以通过它的索引来访问任何元素。List更像长度动态变换的数组。 &emsp;&emsp;Map是一个将key映射到value的对象.一个Map不能包含重复的key：每个key最多只能映射一个value。 一些其它的接口有Queue、Dequeue、SortedSet、SortedMap和ListIterator。 4、为何Collection不从Cloneable和Serializable接口继承？&emsp;&emsp;Collection接口指定一组对象，对象即为它的元素。如何维护这些元素由Collection的具体实现决定。例如，一些如List的Collection实现允许重复的元素，而其它的如Set就不允许。很多Collection实现有一个公有的clone方法。然而，把它放到集合的所有实现中也是没有意义的。这是因为Collection是一个抽象表现。重要的是实现。 &emsp;&emsp;当与具体实现打交道的时候，克隆或序列化的语义和含义才发挥作用。所以，具体实现应该决定如何对它进行克隆或序列化，或它是否可以被克隆或序列化。 &emsp;&emsp;在所有的实现中授权克隆和序列化，最终导致更少的灵活性和更多的限制。特定的实现应该决定它是否可以被克隆和序列化。 5、为何Map接口不继承Collection接口？&emsp;&emsp;尽管Map接口和它的实现也是集合框架的一部分，但Map不是集合，集合也不是Map。因此，Map继承Collection毫无意义，反之亦然。 &emsp;&emsp;如果Map继承Collection接口，那么元素去哪儿？Map包含key-value对，它提供抽取key或value列表集合的方法，但是它不适合“一组对象”规范。 6、Iterator是什么？&emsp;&emsp;Iterator接口提供遍历任何Collection的接口。我们可以从一个Collection中使用迭代器方法来获取迭代器实例。迭代器取代了Java集合框架中的Enumeration。迭代器允许调用者在迭代过程中移除元素。 7、Enumeration和Iterator接口的区别？&emsp;&emsp;Enumeration的速度是Iterator的两倍，也使用更少的内存。Enumeration是非常基础的，也满足了基础的需要。但是，与Enumeration相比，Iterator更加安全，因为当一个集合正在被遍历的时候，它会阻止其它线程去修改集合。 &emsp;&emsp;迭代器取代了Java集合框架中的Enumeration。迭代器允许调用者从集合中移除元素，而Enumeration不能做到。为了使它的功能更加清晰，迭代器方法名已经经过改善。 源码如下： 123456789101112package java.util; public interface Enumeration&lt;E&gt; &#123; boolean hasMoreElements(); E nextElement(); &#125; public interface Iterator&lt;E&gt; &#123; boolean hasNext(); E next(); void remove(); &#125; (01) 函数接口不同 &emsp;&emsp;Enumeration 只有2个函数接口。 通过Enumeration，我们只能读取集合的数据，而不能对数据进行修改。 &emsp;&emsp;Iterator 只有3个函数接口。 Iterator除了能读取集合的数据之外，也能数据进行删除操作。 (02) Iterator 支持 fail-fast 机制，而 Enumeration 不支持 &emsp;&emsp;Enumeration 是JDK 1.0添加的接口。使用到它的函数包括Vector、Hashtable等类，这些类都是JDK 1.0中加入的，Enumeration存在的目的就是为它们提供遍历接口。Enumeration本身并没有支持同步，而在Vector、Hashtable实现Enumeration时，添加了同步。 &emsp;&emsp;而Iterator 是JDK 1.2才添加的接口，它也是为了HashMap、ArrayList等集合提供遍历接口。Iterator是支持fail-fast机制的：当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。 8、Iterator和ListIterator的区别 ListIterator有add()方法，可以向List中添加对象，而Iterator不能。 ListIterator和Iterator都有hasNext()和next()方法，可以实现顺序向后遍历，但是ListIterator有hasPrevious()和previous()方法，可以实现逆向（顺序向前）遍历。Iterator就不可以。 ListIterator可以定位当前的索引位置，nextIndex()和previousIndex()可以实现。Iterator没有此功能。 都可实现删除对象，但是ListIterator可以实现对象的修改，set()方法可以实现。Iierator仅能遍历，不能修改。 9、为何迭代器没有一个方法可以直接获取下一个元素，而不需要移动游标？&emsp;&emsp;它可以在当前Iterator的顶层实现，但是它用得很少，如果将它加到接口中，每个继承都要去实现它，这没有意义。 10、Iterater和ListIterator之间有什么区别？ （1）我们可以使用Iterator来遍历Set和List集合，而ListIterator只能遍历List。 （2）Iterator只可以向前遍历，而LIstIterator可以双向遍历。 （3）ListIterator从Iterator接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。 11、遍历一个List有哪些不同的方式？ 使用普通for循环遍历 使用增强for循环遍历 使用iterator迭代器遍历 使用ListIterator迭代器遍历 &emsp;&emsp;使用迭代器更加线程安全，因为它可以确保，在当前遍历的集合元素被更改的时候，它会抛出ConcurrentModificationException。 12、通过迭代器fail-fast属性，你明白了什么？&emsp;&emsp;每次我们尝试获取下一个元素的时候，Iterator fail-fast属性检查当前集合结构里的任何改动。如果发现任何改动，它抛出ConcurrentModificationException。Collection中所有Iterator的实现都是按fail-fast来设计的（ConcurrentHashMap和CopyOnWriteArrayList这类并发集合类除外）。 13、fail-fast与fail-safe有什么区别？&emsp;&emsp;Iterator的fail-fast属性与当前的集合共同起作用，因此它不会受到集合中任何改动的影响。Java.util包中的所有集合类都被设计为fail-fast的，而java.util.concurrent中的集合类都为fail-safe的。Fail-fast迭代器抛出ConcurrentModificationException，而fail-safe迭代器从不抛出ConcurrentModificationException。 14、在迭代一个集合的时候，如何避免 ConcurrentModificationException？&emsp;&emsp;在遍历一个集合的时候，我们可以使用并发集合类来避免修改并发异常ConcurrentModificationException，比如使用CopyOnWriteArrayList，而不是ArrayList。 15、为何Iterator接口没有具体的实现？&emsp;&emsp;Iterator接口定义了遍历集合的方法，但它的实现则是集合实现类的责任。每个能够返回用于遍历的Iterator的集合类都有它自己的Iterator实现内部类。 &emsp;&emsp;这就允许集合类去选择迭代器是fail-fast还是fail-safe的。比如，ArrayList迭代器是fail-fast的，而CopyOnWriteArrayList迭代器是fail-safe的。 16、UnsupportedOperationException是什么？&emsp;&emsp;UnsupportedOperationException是用于表明操作不支持的异常。在JDK类中已被大量运用，在集合框架java.util.Collections.UnmodifiableCollection将会在所有add和remove操作中抛出这个异常。 17、在Java中，HashMap是如何工作的？&emsp;&emsp;HashMap在Map.Entry静态内部类实现中存储key-value对。HashMap使用哈希算法，在put和get方法中，它使用hashCode()和equals()方法。当我们通过传递key-value对调用put方法的时候，HashMap使用Key hashCode()和哈希算法来找出存储key-value对的索引。Entry存储在LinkedList中，所以如果存在entry，它使用equals()方法来检查传递的key是否已经存在，如果存在，它会覆盖value，如果不存在，它会创建一个新的entry然后保存。当我们通过传递key调用get方法时，它再次使用hashCode()来找到数组中的索引，然后使用equals()方法找出正确的Entry，然后返回它的值。下面的图片解释了详细内容。 &emsp;&emsp;其它关于HashMap比较重要的问题是容量、负荷系数和阀值调整。HashMap默认的初始容量是32，负荷系数是0.75。阀值是为负荷系数乘以容量，无论何时我们尝试添加一个entry，如果map的大小比阀值大的时候，HashMap会对map的内容进行重新哈希，且使用更大的容量。容量总是2的幂，所以如果你知道你需要存储大量的key-value对，比如缓存从数据库里面拉取的数据，使用正确的容量和负荷系数对HashMap进行初始化是个不错的做法。 18、hashCode()和equals()方法有何重要性？&emsp;&emsp;HashMap使用Key对象的hashCode()和equals()方法去决定key-value对的索引。当我们试着从HashMap中获取值的时候，这些方法也会被用到。如果这些方法没有被正确地实现，在这种情况下，两个不同Key也许会产生相同的hashCode()和equals()输出，HashMap将会认为它们是相同的，然后覆盖它们，而非把它们存储到不同的地方。同样的，所有不允许存储重复数据的集合类都使用hashCode()和equals()去查找重复，所以正确实现它们非常重要。equals()和hashCode()的实现应该遵循以下规则： （1）如果o1.equals(o2)为 true，那么o1.hashCode() == o2.hashCode()总是为true的。 （2）如果o1.hashCode() == o2.hashCode()，并不意味着o1.equals(o2)会为true。 19、我们能否使用任何类作为Map的key？我们可以使用任何类作为Map的key，然而在使用它们之前，需要考虑以下几点： （1）如果类重写了equals()方法，它也应该重写hashCode()方法。 （2）类的所有实例需要遵循与equals()和hashCode()相关的规则。请参考之前提到的这些规则。 （3）如果一个类没有使用equals()，你不应该在hashCode()中使用它。 （4）用户自定义key类的最佳实践是使之为不可变的，这样，hashCode()值可以被缓存起来，拥有更好的性能。不可变的类也可以确保hashCode()和equals()在未来不会改变，这样就会解决与可变相关的问题了。 20、Map接口提供了哪些不同的集合视图？ Map接口提供三个集合视图： （1）Set keyset()：返回map中包含的所有key的一个Set视图。集合是受map支持的，map的变化会在集合中反映出来，反之亦然。当一个迭代器正在遍历一个集合时，若map被修改了（除迭代器自身的移除操作以外），迭代器的结果会变为未定义。集合支持通过Iterator的Remove、Set.remove、removeAll、retainAll和clear操作进行元素移除，从map中移除对应的映射。它不支持add和addAll操作。 （2）Collection values()：返回一个map中包含的所有value的一个Collection视图。这个collection受map支持的，map的变化会在collection中反映出来，反之亦然。当一个迭代器正在遍历一个collection时，若map被修改了（除迭代器自身的移除操作以外），迭代器的结果会变为未定义。集合支持通过Iterator的Remove、Set.remove、removeAll、retainAll和clear操作进行元素移除，从map中移除对应的映射。它不支持add和addAll操作。 （3）Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()：返回一个map钟包含的所有映射的一个集合视图。这个集合受map支持的，map的变化会在collection中反映出来，反之亦然。当一个迭代器正在遍历一个集合时，若map被修改了（除迭代器自身的移除操作，以及对迭代器返回的entry进行setValue外），迭代器的结果会变为未定义。集合支持通过Iterator的Remove、Set.remove、removeAll、retainAll和clear操作进行元素移除，从map中移除对应的映射。它不支持add和addAll操作。 21、HashMap和Hashtable有何不同？ （1）HashMap允许key和value为null，而HashTable不允许。 （2）Hashtable是同步的，而HashMap不是。所以HashMap适合单线程环境，Hashtable适合多线程环境。 （3）在Java1.4中引入了LinkedHashMap，HashMap的一个子类，假如你想要遍历顺序，你很容易从HashMap转向LinkedHashMap，但是Hashtable不是这样的，它的顺序是不可预知的。 （4）HashMap提供对key的Set进行遍历，因此它是fail-fast的，但Hashtable提供对key的Enumeration进行遍历，它不支持fail-fast。 （5）Hashtable被认为是个遗留的类，如果你寻求在迭代的时候修改Map，你应该使用CocurrentHashMap。 22、如何决定选用HashMap还是TreeMap？&emsp;&emsp;对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。 23.ArrayList和Vector有何异同点？ ArrayList和Vector在很多时候都很类似。 （1）两者都是基于索引的，内部由一个数组支持。 （2）两者维护插入的顺序，我们可以根据插入顺序来获取元素。 （3）ArrayList和Vector的迭代器实现都是fail-fast的。 （4）ArrayList和Vector两者允许null值，也可以使用索引值对元素进行随机访问。 以下是ArrayList和Vector的不同点。 （1）Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。 （2）ArrayList比Vector快，它因为有同步，不会过载。 （3）ArrayList更加通用，因为我们可以使用Collections工具类轻易地获取同步列表和只读列表。 24、Array和ArrayList有何区别？什么时候更适合用Array？ Array可以容纳基本类型和对象，而ArrayList只能容纳对象。 Array是指定大小的，而ArrayList大小是固定的。 Array没有提供ArrayList那么多功能，比如addAll、removeAll和iterator等。尽管ArrayList明显是更好的选择，但也有些时候Array比较好用。 （1）如果列表的大小已经指定，大部分情况下是存储和遍历它们。 （2）对于遍历基本数据类型，尽管Collections使用自动装箱来减轻编码任务，在指定大小的基本类型的列表上工作也会变得很慢。 （3）如果你要使用多维数组，使用[][]比List&lt;List&lt;&gt;&gt;更容易。 25、ArrayList和LinkedList有何区别？ ArrayList和LinkedList两者都实现了List接口，但是它们之间有些不同。 （1）ArrayList是由Array所支持的基于一个索引的数据结构，所以它提供对元素的随机访问，复杂度为O(1)，但LinkedList存储一系列的节点数据，每个节点都与前一个和下一个节点相连接。所以，尽管有使用索引获取元素的方法，内部实现是从起始点开始遍历，遍历到索引的节点然后返回元素，时间复杂度为O(n)，比ArrayList要慢。 （2）与ArrayList相比，在LinkedList中插入、添加和删除一个元素会更快，因为在一个元素被插入到中间的时候，不会涉及改变数组的大小，或更新索引。 （3）LinkedList比ArrayList消耗更多的内存，因为LinkedList中的每个节点存储了前后节点的引用。 26、哪些集合类提供对元素的随机访问？&emsp;&emsp;ArrayList、HashMap、TreeMap和HashTable类提供对元素的随机访问。 27、EnumSet是什么？&emsp;&emsp;java.util.EnumSet是使用枚举类型的集合实现。当集合创建时，枚举集合中的所有元素必须来自单个指定的枚举类型，可以是显示的或隐示的。EnumSet是不同步的，不允许值为null的元素。它也提供了一些有用的方法，比如copyOf(Collection c)、of(E first,E…rest)和complementOf(EnumSet s)。 28、哪些集合类是线程安全的？&emsp;&emsp;Vector、HashTable、Properties和Stack是同步类，所以它们是线程安全的，可以在多线程环境下使用。Java1.5并发API包括一些集合类，允许迭代时修改，因为它们都工作在集合的克隆上，所以它们在多线程环境中是安全的。 29、并发集合类是什么？&emsp;&emsp;Java1.5并发包（java.util.concurrent）包含线程安全集合类，允许在迭代时修改集合。迭代器被设计为fail-fast的，会抛出ConcurrentModificationException。一部分类为：CopyOnWriteArrayList、 ConcurrentHashMap、CopyOnWriteArraySet。 30、BlockingQueue是什么？&emsp;&emsp;Java.util.concurrent.BlockingQueue是一个队列，在进行检索或移除一个元素的时候，它会等待队列变为非空；当在添加一个元素时，它会等待队列中的可用空间。BlockingQueue接口是Java集合框架的一部分，主要用于实现生产者-消费者模式。我们不需要担心等待生产者有可用的空间，或消费者有可用的对象，因为它都在BlockingQueue的实现类中被处理了。Java提供了集中BlockingQueue的实现，比如ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue,、SynchronousQueue等。 31、队列和栈是什么，列出它们的区别？&emsp;&emsp;栈和队列两者都被用来预存储数据。java.util.Queue是一个接口，它的实现类在Java并发包中。队列允许先进先出（FIFO）检索元素，但并非总是这样。Deque接口允许从两端检索元素。栈与队列很相似，但它允许对元素进行后进先出（LIFO）进行检索。 &emsp;&emsp;Stack是一个扩展自Vector的类，而Queue是一个接口。 32、Collections类是什么？&emsp;&emsp;Java.util.Collections是一个工具类仅包含静态方法，它们操作或返回集合。它包含操作集合的多态算法，返回一个由指定集合支持的新集合和其它一些内容。这个类包含集合框架算法的方法，比如折半搜索、排序、混编和逆序等。 33、Comparable和Comparator接口是什么？&emsp;&emsp;如果我们想使用Array或Collection的排序方法时，需要在自定义类里实现Java提供Comparable接口。Comparable接口有compareTo(T OBJ)方法，它被排序方法所使用。我们应该重写这个方法，如果“this”对象比传递的对象参数更小、相等或更大时，它返回一个负整数、0或正整数。但是，在大多数实际情况下，我们想根据不同参数进行排序。比如，作为一个CEO，我想对雇员基于薪资进行排序，一个HR想基于年龄对他们进行排序。这就是我们需要使用Comparator接口的情景，因为Comparable.compareTo(Object o)方法实现只能基于一个字段进行排序，我们不能根据对象排序的需要选择字段。Comparator接口的compare(Object o1, Object o2)方法的实现需要传递两个对象参数，若第一个参数比第二个小，返回负整数；若第一个等于第二个，返回0；若第一个比第二个大，返回正整数。 34、Comparable和Comparator接口有何区别？&emsp;&emsp;Comparable和Comparator接口被用来对对象集合或者数组进行排序。Comparable接口被用来提供对象的自然排序，我们可以使用它来提供基于单个逻辑的排序。 &emsp;&emsp;Comparator接口被用来提供不同的排序算法，我们可以选择需要使用的Comparator来对给定的对象集合进行排序。 35、我们如何对一组对象进行排序？&emsp;&emsp;如果我们需要对一个对象数组进行排序，我们可以使用Arrays.sort()方法。如果我们需要排序一个对象列表，我们可以使用Collection.sort()方法。两个类都有用于自然排序（使用Comparable）或基于标准的排序（使用Comparator）的重载方法sort()。Collections内部使用数组排序方法，所有它们两者都有相同的性能，只是Collections需要花时间将列表转换为数组。 36、当一个集合被作为参数传递给一个函数时，如何才可以确保函数不能修改它？&emsp;&emsp;在作为参数传递之前，我们可以使用Collections.unmodifiableCollection(Collection c)方法创建一个只读集合，这将确保改变集合的任何操作都会抛出UnsupportedOperationException。 37、我们如何从给定集合那里创建一个synchronized的集合？&emsp;&emsp;我们可以使用Collections.synchronizedCollection(Collection c)根据指定集合来获取一个synchronized（线程安全的）集合。 38、集合框架里实现的通用算法有哪些？&emsp;&emsp;Java集合框架提供常用的算法实现，比如排序和搜索。Collections类包含这些方法实现。大部分算法是操作List的，但一部分对所有类型的集合都是可用的。部分算法有排序、搜索、混编、最大最小值。 39、大写的O是什么？举几个例子？&emsp;&emsp;大写的O描述的是，就数据结构中的一系列元素而言，一个算法的性能。Collection类就是实际的数据结构，我们通常基于时间、内存和性能，使用大写的O来选择集合实现。比如：例子1：ArrayList的get(index i)是一个常量时间操作，它不依赖list中元素的数量。所以它的性能是O(1)。例子2：一个对于数组或列表的线性搜索的性能是O(n)，因为我们需要遍历所有的元素来查找需要的元素。 40、与Java集合框架相关的有哪些最好的实践？ （1）根据需要选择正确的集合类型。比如，如果指定了大小，我们会选用Array而非ArrayList。如果我们想根据插入顺序遍历一个Map，我们需要使用TreeMap。如果我们不想重复，我们应该使用Set。 （2）一些集合类允许指定初始容量，所以如果我们能够估计到存储元素的数量，我们可以使用它，就避免了重新哈希或大小调整。 （3）基于接口编程，而非基于实现编程，它允许我们后来轻易地改变实现。 （4）总是使用类型安全的泛型，避免在运行时出现ClassCastException。 （5）使用JDK提供的不可变类作为Map的key，可以避免自己实现hashCode()和equals()。 （6）尽可能使用Collections工具类，或者获取只读、同步或空的集合，而非编写自己的实现。它将会提供代码重用性，它有着更好的稳定性和可维护性。 41、什么是CopyOnWriteArrayList，它与ArrayList有何不同？&emsp;&emsp;CopyOnWriteArrayList是ArrayList的一个线程安全的变体，其中所有可变操作（add、set等等）都是通过对底层数组进行一次新的复制来实现的。相比较于ArrayList它的写操作要慢一些，因为它需要实例的快照。 &emsp;&emsp;CopyOnWriteArrayList中写操作需要大面积复制数组，所以性能肯定很差，但是读操作因为操作的对象和写操作不是同一个对象，读之间也不需要加锁，读和写之间的同步处理只是在写完后通过一个简单的”=”将引用指向新的数组对象上来，这个几乎不需要时间，这样读操作就很快很安全，适合在多线程里使用，绝对不会发生ConcurrentModificationException ，因此CopyOnWriteArrayList适合使用在读操作远远大于写操作的场景里，比如缓存。 42、迭代器和枚举之间的区别&emsp;&emsp;如果面试官问这个问题，那么他的意图一定是让你区分Iterator不同于Enumeration的两个方面： Iterator允许移除从底层集合的元素。 Iterator的方法名是标准化的。 43、什么是快速失败的故障安全迭代器？&emsp;&emsp;快速失败的Java迭代器可能会引发ConcurrentModifcationException在底层集合迭代过程中被修改。故障安全作为发生在实例中的一个副本迭代是不会抛出任何异常的。快速失败的故障安全范例定义了当遭遇故障时系统是如何反应的。例如，用于失败的快速迭代器ArrayList和用于故障安全的迭代器ConcurrentHashMap。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>Java基础</tag>
        <tag>Collection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归之阶乘以及斐波那契数列]]></title>
    <url>%2F2019%2F08%2F08%2F%E9%80%92%E5%BD%92%E4%B9%8B%E9%98%B6%E4%B9%98%E4%BB%A5%E5%8F%8A%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[概述 1、递：传递、逐渐的、一个接一个；归：回去，回到简单原始的状态。 2、有一种从大到小，从复杂到简单的传递过程。 3、递归：方法自己调用自己。 4、递归代码的特点： （1）自己调用自己：总体逻辑不变，但是规模再缩小；由于自己调用自己，所以功能都要单独的定义一个方法 （2）代码会有两个分支：自己调用自己的分支，规模还比较大的时候，无法直接简单解决的时候，不需要自己调用自己的分支，规模已经简单到不需要自己调用自己，而使用一个很简单的操作就可以完成。 （3）每次递归调用的时候，朝着规模减小的方向、朝着不需要递归的方向调用。 递归的注意事项 1、递归的效率比较低，因为方法需要不断的进栈和出栈。 2、递归的算法比较浪费栈内存的空间，栈内存本身比较小，很容易将栈内存的内存空间耗尽，那么程序就无法继续执行下去，报出一个错误：StackOverflowError 栈内存溢出。 3、国外有一个网站：StackOverflow，专业版的知乎 4、递归算法的好处：思路比较简单 5、所有的递归算法，都有非递归的解决方式，只不过非递归的算法设计比较困难。 阶乘&emsp;&emsp;阶乘是基斯顿·卡曼（Christian Kramp，1760～1826）于 1808 年发明的运算符号，是数学术语。 &emsp;&emsp;一个正整数的阶乘（factorial）是所有小于及等于该数的正整数的积，并且0的阶乘为1。自然数n的阶乘写作n!。1808年，基斯顿·卡曼引进这个表示法。 &emsp;&emsp;亦即n!=1×2×3×…×n。阶乘亦可以递归方式定义：0!=1，n!=(n-1)!×n。&emsp;&emsp;实现代码如下： 123public static int factorial(int n) &#123; return n &gt; 1 ? n * factorial(n - 1) : 1;&#125; 斐波那契数列&emsp;&emsp;斐波那契数列（Fibonacci sequence）的定义：斐波那契数列指的是这样一个数列 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233，377，610，987，1597，2584，4181，6765，10946，17711，28657，46368……..，这个数列从第3项开始，每一项都等于前两项之和。 &emsp;&emsp;斐波那契数列又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”。在数学上，斐波纳契数列以如下被以递归的方法定义：F(0)=0，F(1)=1, F(n)=F(n-1)+F(n-2)（n&gt;=2，n∈N*）。 斐波那契数列代码实现 第一种方式：直接赋值法 1234567891011121314151617181920public static void fib(int num) &#123; //定义第一个加数a，初始值为1；定义第二个加数b，初始值为1；定义两个加数之和为c，初始值为0 int a = 1; int b = 1; int c = 0; //首先在控制台打印出数列中第一个数和第二个数的值 System.out.print(a + "\t" + b + "\t"); //建立一个for循环，用于循环输出数列中第三位至第 num 位的数字 for (int i = 3; i &lt;= num; i++) &#123; //第三个数即为c，a+b等于c的值 c = a + b; //将第一个加数a赋值为数列中的第二个数b的值 a = b; //将第二个加数b赋值为数列中的第三个数c的值 b = c; //在第二次循环打印时，将打印数列中的第四个数为：b + c = b + (a + b) System.out.print(c + "\t"); &#125; &#125; 第二种方式：使用数组打印法 123456789101112131415public static void fib2 (int num)&#123; //建立一个长度为 num 的数组用于存放数列中的数 int[] arr = new int[num]; //先定义数列中的第一个和第二个数 arr[0] = 1; arr[1] = 1; //建立一个for循环，打印数组中的元素 for(int i = 0;i &lt; arr.length;i++) &#123; //判断：当打印第三个数前，给第三个数赋值 if(i &gt; 1) &#123; arr[i] = arr[i - 2] + arr[i - 1]; &#125; System.out.print(arr[i] + "\t"); &#125; &#125; 第三种方式：调用函数 123456public static int fib3(int num) &#123; if (num == 1 || num == 2) &#123; return 1; &#125; return fib3(num - 2) + fib3(num - 1);&#125;]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>Java基础</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础之集合总结]]></title>
    <url>%2F2019%2F08%2F07%2FJava%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[集合&emsp;&emsp;在Java编程语言中的容器主要是Array（数组）和collection（集合），下面我们就来看看Java中的容器： 集合和数组 数组（可以存储基本数据类型和引用数据类型）是用来存储对象的一种容器，但是数组的长度固定不变的，不适合在对象数量未知的情况下使用。 集合（只能存储引用数据类型对象，存储的对象类型可以是不同类型的）的长度可变，可在多数情况下使用。 注意：虽然集合不能存储基本数据类型，但是可以存储基本数据类型的包装类类型。 集合框架层次关系&emsp;&emsp;这里小编就不介绍数组了，本文主要讲解集合的知识点总结。如下图所示：在图中，实线边框的是实现类，折线边框的是抽象类，点线边框的是接口。 说明： &emsp;&emsp;Collection接口是集合类的根接口，Java中没有提供这个接口的直接的实现类。但是有两个子接口，就是Set和List。Set集合中不能包含重复的元素。List集合是一个有序的集合，可重复元素，提供了按索引访问元素的方式。 &emsp;&emsp;Map是Java.util包中的另一个接口，注意，它和我们前面说的Collection接口没有任何关系，是互相独立的，也是Java集合中的一部分。 &emsp;&emsp;Map集合是以键值对的形式存储数据的，Map集合不能包含重复的key，一个key映射一个value。但是可以包含相同的value。 &emsp;&emsp;Iterator 迭代器，Java中的所有的集合类都实现了该接口，这是一个用于遍历集合的接口，该接口中主要包含三个方法，源码如下： 123456789101112public interface Iterator&lt;E&gt; &#123; //是否还有下一个元素 boolean hasNext(); //返回下一个元素 E next(); //删除当前元素 default void remove() &#123; throw new UnsupportedOperationException("remove"); &#125;&#125; 集合家族的体系介绍 1、集合分类 单列集合：每个元素都是一个独立的个体，存储的都是单身狗。 双列集合：每个元素都是针对一对数据进行的，一对数据才是一个存储单元，存储的都是一对一对的小情侣。 2、单列集合的体系结构： Collection —-&gt; 单列集合顶层接口 List —-&gt; 有序的子接口 ArrayList —-&gt; 顺序存储，查改快，增删慢 LinkedList —-&gt; 链式存储，增删快，查改慢 vector —-&gt; 顺序存储，各种操作慢 Set —-&gt; 无序且元素唯一子接口 HashSet —-&gt; 哈希存储 LinkedHashSet —-&gt; 是HashSet的子类, 哈希加链表的方式存储 3、双列集合的体系 Map —-&gt; 双列集合的顶层接口 HashMap —-&gt; 哈希表存储 LinkedHashMap —-&gt; 是HashMap的子类, 哈希加链表的方式存储 整体总结集合（Collection）&emsp;&emsp;Collection 的特点： 部分集合是有序的，部分集合是无序的，这里的有序指的是存储有序 部分集合是可排序的，部分集合是不可排序 部分集合是可重复的，部分集合是不可重复，唯一的 单列集合List接口List接口 特点: 1.集合是有序的(存储有序) 2.有索引，方便查找和修改 3.List集合可重复 12345 public boolean add(E e) &#123;ensureCapacityInternal(size + 1); // Increments modCount!!elementData[size++] = e;return true; &#125; 结论:无论添加重复还是不重复的元素，结果都是返回添加成功，所以List集合是可重复的 4.允许存储null值 ArrayList ArrayList集合的特点： 1.有序，有索引 2.元素可以重复 3.可以存储null值 4.随机访问速度快，修改快，增加/插入或者移除/删除的效率慢 5.线程不安全 如何去重复？ 1.创建一个新集合 2.选择排序思想去重复 如何排序? Collections.sort(list); 如何变安全? Collections.synchronizedList(list); 遍历的方式（六种）: 1、Object[] toArray() 2、普通for循环 3、增强for循环 4、Iterator iterator() 5、ListIterator listIterator() 6、 T[] toArray(T[] a) ListIterator 列表迭代器&emsp;&emsp;ListIterator接口是List特有的迭代器，允许程序员按任一方向遍历列表、迭代期间修改列表，并获得迭代器在列表中的当前位置。 常用方法boolean hasNext()以正向遍历列表时，如果列表迭代器有多个元素，则返回 true（换句话说，如果next 返回一个元素而不是抛出异常，则返回 true）。 E next()返回列表中的下一个元素。 boolean hasPrevious()如果以逆向遍历列表，列表迭代器有多个元素，则返回 true。 E previous()返回列表中的前一个元素。 Vector&emsp;&emsp;该集合类似于ArrayList集合，可以说成老版的ArrayList，该集合在jdk1.0版本时就有了。 &emsp;&emsp;Vector集合底层数据结构也是数组，增加、删除元素的性能就比较差了，相对于ArrayList是线程安全的、效率低。 Vector类特有功能123public void addElement(E obj)public E elementAt(int index)public Enumeration elements() LinkedList LinkedList类概述 1、底层数据结构是链表 2、插入和移除性能高，查询效率低。 3、线程不安全，效率高。 4、存储有序 5、可以重复（并且可以存储null值） 6、不可排序 &emsp;&emsp;双链表实现了List和Deque以及Queue接口。 实现所有可选列表操作，并允许所有元素（包括null ）。&emsp;&emsp;该集合具有队列、栈、链表的数据特性。可以使用LinkedList实现栈和队列结构。 Stack底层数据结构是使用的栈结构，先进后出的形式。 方法: 12345boolean empty() 测试堆栈是否为空。 E peek() 查看堆栈顶部的对象，但不从堆栈中移除它。 E pop() 移除堆栈顶部的对象，并作为此函数的值返回该对象。 E push(E item) 把项压入堆栈顶部。 int search(Object o) 返回对象在堆栈中的位置，以 1 为基数。 java.util.EmptyStackException EmptyStackException: 空栈异常 产生原因: 栈里面的数据没有了 解决办法: 在弹栈之前做判断Set接口 Set集合的概述 1.Set是一个不包含重复元素的 Collection的另一子接口 2.特点: 无序: 没有任何的前后区别.所有的元素没有位置的概念,所有的元素都存储在集合中.无序指的你添加顺序和取出顺序可能不一样.取出顺序的不可预知. 没有索引: 集合中元素无法通过位置区分,相同元素就无法区分. 唯一(不能重复):没有位置区分, 相同的元素就无法分别, 所以不能重复. 可以存储null值，但只能存储一个null值。 3.Set的是一个接口, 无法实例化,只能指向HashSet实现类才能研究Set集合中的方法:HastSet: 就是Set的实现类, 底层是使用哈希表存储方法存储Set集合的元素. 4.存储特点: 1.相同的元素无法存储进Set集合,相同只能保存一份; 2.集合本身不保证顺序: 存储的顺序和取出顺序顺序不一致. HashSet HashSet类概述&emsp;&emsp;此类实现 Set 接口，由哈希表（实际上是一个 HashMap 实例）支持。它不保证 set 的迭代顺序；特别是它不保证该顺序恒久不变。此类允许使用null元素。HashSet保证元素唯一。 &emsp;&emsp;底层数据结构是哈希表，哈希表依赖于哈希值存储 &emsp;&emsp;添加元素时保证元素唯一，本质底层依赖两个方法: 123int hashCode() boolean equals(Object obj) HashSet保证元素唯一的原理 1.某个对象,在即将存储到HashSet集合时候,首先获取obj的hashCode方法值 2.在集合中与每个元素的哈希值比较, 如果都和obj的哈希值不同, 说明obj在集合中不存在,那么直接添加obj. 3.在集合中有若干元素的哈希值和obj哈希值相同，但是此时不能说明obj已经存在于集合中了，这时我们需要使用equals判断obj是否和自己哈希值相同元素是否相等. 4.如果obj和所有相同哈希值一样的元素比较之后返回值都是false.那么就说明obj不存在于集合中,可以将obj添加到集合中. 5.如果obj和其中某个相同哈希值元素比较的结果为true.那么就说明obj已经存在于集合中. obj就不能向集合中添加. 自定义类型如何保证HashSet存储时元素的唯一性 1.重写hashCode方法相同对象,一定有相同的哈希值不同对象,尽量有不同哈希值, 为了提供哈希表存储效率.重写都是围绕着对象的属性重写; 2.重写equals方法:不仅仅比较两个对象地址,还要两个对象属性. 3.重写操作:使用快捷键: alt+shift+s h LinkedHashSet 1.LinkedHashSet是HashSet一个子类, 和HashSet一样都能保证元素的唯一性. 2.底层存储原理和HashSet不一样.底层使用哈希表+链接列表方法存储数据. 哈希表保证元素的唯一. 链表用来记录元素存储的先后顺序. 链表通过前一个元素,记录后一个元素位置，来维护它有序性. 3.存储效果: 元素具有可预知迭代顺序,元素添加顺序和取出的顺序一致. 4.LinkedHashSet的应用场景: 如果你想使用一个集合,既保证元素唯一性,又想保证元素的存储顺序,就使用LinkedHashSet. TreeSet&emsp;&emsp;基于 TreeMap 的 NavigableSet 实现。使用元素的自然顺序对元素进行排序，或者根据创建 set 时提供的 Comparator 进行排序，具体取决于使用的构造方法。 排序方式完全取决于使用的构造方法。 1、创建TreeSet集合是使用的是无参构造器时，Comparator为null ，则底层使用的是自然排序法。 1234567public TreeSet() &#123; this(new TreeMap&lt;E,Object&gt;());&#125;public TreeMap() &#123; comparator = null;&#125; 2、创建TreeSet集合时使用的是有参构造器时，Comparator不为null，则底层使用的时比较器排序 1234567public TreeSet(Comparator&lt;? super E&gt; comparator) &#123; this(new TreeMap&lt;&gt;(comparator));&#125;public TreeMap(Comparator&lt;? super K&gt; comparator) &#123; this.comparator = comparator;&#125; &emsp;&emsp;TreeSet保证元素的排序和唯一性的:底层数据结构是红黑树(自平衡的二叉树) &emsp;&emsp;一般情况下大部分系统类都重写了Comparable接口，而我们自定义的类如果要使用TreeSet集合时，并且使用自然排序法时，该类必须实现Comparable接口并实现该接口中的方法自定义自己的排序规则。 &emsp;&emsp;注意：如果我们同时实现了自然排序和比较器排序，那么比较器排序优先于自然排序。我们在开发中一般使用比较器排序，并且使用匿名内部类的方式实现。 双列集合Map接口&emsp;&emsp;Map是双列集合的顶层接口 Map集合的特点: key(键值): 在map中唯一,不可重复 value(值): 在map中不要求唯一, 可以多个key值对应相同value值. key和value: 就称之为键值对 每个key值只能对应一个value值. Map和Collection区别 1.Map是双列集合, Collection是单列集合 2.Map的键值唯一的, Collection下Set接口实现类存储元素是唯一的 3.Map集合所有操作和算法都是针对于key值有效.Set集合下所有操作和算法针对于元素有效.原因是Set的底层就是Map. HashMap&emsp;&emsp;基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。） &emsp;&emsp;此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 特点： 键无序，唯一，类似于Set集合 值有序，可重复，类似于List 底层数据结构是哈希表，保证键唯一 允许键为null，值为null &emsp;&emsp;HashMap存储自定义类型作为key时,无法保证元素的唯一性. 原因是HashMap的底层是使用的是哈希算法来保证元素的唯一性。 如何保证自定类型作为key时唯一: 重写equals和hashCode方法. 说明: HashMap保证key值唯一性的原理和HashSet保证元素唯一的原理一样. HashMap和HashSet的关系: 1.HashSet是由HashMap实现的, HashSet就是HashMap的key值那一列; 2.HashSet的内部隐藏了HashMap的value值那一列. HashSet没有提供操作value值那一列方法. Hashtable&emsp;&emsp;此类实现一个哈希表，该哈希表将键映射到相应的值。任何非 null 对象都可以用作键或值 特点： 不允许null键和null值 线程安全，效率低 面试题：HashMap和Hashtable的区别 HashMap是不安全的不同步的效率高的 允许null键和null值 Hashtable是安全的同步的效率低的 不允许null键和null值 底层都是哈希表结构 LinkedHashMap&emsp;&emsp;LinkedHashMap 是 HashMap 接口的一个子类 特点：键有序，唯一，值有序，可重复，类似于List底层数据结构是哈希表和链表，哈希表保证键唯一，链表保证键有序 TreeMap&emsp;&emsp;基于红黑树（Red-Black tree）的 NavigableMap 实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。 特点： 键可排序，唯一， 值有序，可重复，类似于List 底层数据结构是自平衡的二叉树，可排序 排序方式类似于TreeSet，分为自然排序和比较器排序，具体取决于使用的构造方法 WeakHashMap&emsp;&emsp;以弱键 实现的基于哈希表的 Map。在 WeakHashMap 中，当某个键不再正常使用时，将自动移除其条目。更精确地说，对于一个给定的键，其映射的存在并不阻止垃圾回收器对该键的丢弃，这就使该键成为可终止的，被终止，然后被回收。丢弃某个键时，其条目从映射中有效地移除，因此，该类的行为与其他的 Map 实现有所不同。 Iterator接口&emsp;&emsp;对 collection 进行迭代的迭代器。迭代器取代了 Java Collections Framework 中的 Enumeration，迭代器依赖于集合而存在。 常用方法： 123456789101112 boolean hasNext() 如果仍有元素可以迭代，则返回 true。 E next() 返回迭代的下一个元素。 注意： 抛出： NoSuchElementException - 没有元素可以迭代。 void remove() 返回迭代的当前元素。 迭代器原理： 在获取迭代器的时候，会创建一个集合的副本，同时创建一个指针指向迭代器集合的起始位置。 HashMap和Hashtable的区别 1、HashMap是Hashtable的轻量级实现（非线程安全的实现），他们都完成了Map接口，主要区别在于HashMap允许空（null）键值（key）,由于非线程安全，效率上可能高于Hashtable。 2、HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。 3、HashMap把Hashtable的contains方法去掉了，改成containsvalue和containsKey。因为contains方法容易让人引起误解。 4、Hashtable继承自Dictionary类,jdk1.0时出现的，而HashMap是Java1.2引进的Map interface的一个实现。 5、最大的不同是，Hashtable的方法是Synchronize的，而HashMap不是，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供外同步。 6、Hashtable和HashMap采用的hash/rehash算法都大概一样，所以性能不会有很大的差异。 相同点：都实现Map接口，都是KEY-VALUE，所用的算法差不多 不同点： HashMap:允许将null作为一个entry的key或者value，线程不安全，效率高一些 Hashtable:不允许将null作为一个entry的key或者value，线程安全，效率低一些 请说出集合框架中线程安全与不安全的类 集合框架中的类 ArrayList 线程不安全 Vector 线程安全 HashMap 线程不安全 Hashtable 线程安全 不是集合中的类 StringBuffer 线程安全的 StringBuilder 线程不安全的]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>集合</tag>
        <tag>collection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java异常分析]]></title>
    <url>%2F2019%2F08%2F07%2FJava%E5%BC%82%E5%B8%B8%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; 相信各位朋友对异常并不陌生，对它我们真的又喜又悲，成功的解决一个BUG那真是欢天喜地，但是又怕遇见它，今天小编就给大家笼统的介绍一下我们的每天相处的好朋友–异常。 Java 异常类结构体系图既然想要了解异常，那么我们首先要了解一下，异常的结构体系： Java异常分析&emsp;Throwable&emsp;&emsp; Throwable 类是 Java 语言中所有错误或异常的超类。只有当对象是此类（或其子类之一）的实例时，才能通过 Java 虚拟机或者 Java throw 语句抛出。&emsp;&emsp;Thowable 类有两个子类的实例，Error 和 Exception，通常用于指示发生了异常情况。通常，这些实例是在异常情况的上下文中新近创建的，因此包含了相关的信息（比如堆栈跟踪数据）。 &emsp; Throwable 的两个子类 Error 和 ExceptionError&emsp;&emsp;Error 是 Throwable 的子类，用于指示合理的应用程序不应该试图捕获的严重问题。大多数这样的错误都是异常条件。虽然 ThreadDeath 错误是一个“正规”的条件，但它也是 Error 的子类，因为大多数应用程序都不应该试图捕获它。Exception&emsp;&emsp;Exception 类及其子类是 Throwable 的一种形式，它指出了合理的应用程序想要捕获的条件。Exception 类分为两大类：RuntimeException （运行异常类） 和 Non_RuntimeException （非运行异常类）： RuntimeException &emsp;运行时异常都是RuntimeException类及其子类异常，如NullPointerException、IndexOutOfBoundsException等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。 &emsp;当出现RuntimeException的时候，我们可以不处理。当出现这样的异常时，总是由虚拟机接管。比如：我们从来没有人去处理过NullPointerException异常，它就是运行时异常，并且这种异常还是最常见的异常之一。 &emsp;出现运行时异常后，如果没有捕获处理这个异常（即没有catch），系统会把异常一直往上层抛，一直到最上层，如果是多线程就由Thread.run()抛出，如果是单线程就被main()抛出。抛出之后，如果是线程，这个线程也就退出了。如果是主程序抛出的异常，那么这整个程序也就退出了。运行时异常是Exception的子类，也有一般异常的特点，是可以被catch块处理的。只不过往往我们不对他处理罢了。也就是说，你如果不对运行时异常进行处理，那么出现运行时异常之后，要么是线程中止，要么是主程序终止。 &emsp;如果不想终止，则必须捕获所有的运行时异常，决不让这个处理线程退出。队列里面出现异常数据了，正常的处理应该是把异常数据舍弃，然后记录日志。不应该由于异常数据而影响下面对正常数据的处理。 非运行异常 &emsp;非运行时异常是RuntimeException以外的异常，类型上都属于Exception类及其子类。如IOException、SQLException等以及用户自定义的Exception异常。对于这种异常，JAVA编译器强制要求我们必需对出现的这些异常进行catch并处理，否则程序就不能编译通过。所以，面对这种异常不管我们是否愿意，只能自己去写一大堆catch块去处理可能的异常。 常见运行时异常 算术异常类：ArithmeticExecption 空指针异常类：NullPointerException 类型强制转换异常：ClassCastException 数组负下标异常：NegativeArrayException 数组下标越界异常：ArrayIndexOutOfBoundsException 违背安全原则异常：SecurityException 字符串转换为数字异常：NumberFormatException 尝试访问null对象成员：NullPointerException 欲得到的数据类型与实际输入的类型不匹配：InputMismatchException 方法接收到非法参数：IllegalArgumentException 常见的编译时异常 不能加载所需的类(常见于多态中向下转型)：ClassNotFoundException 文件未找到异常：FileNotFoundException 提供关于数据库访问错误或其他错误信息的异常：SQLException 当发生某种 I/O 异常时，抛出此异常：IOException 当数据格式发生错误时，抛出此异常：DataFormatException 表示解析时出现意外错误抛出此异常：ParseException 异常的捕获和处理Java异常的捕获和处理是一个不容易把握的事情，如果处理不当，不但会让程序代码的可读性大大降低，而且导致系统性能低下，甚至引发一些难以发现的错。 Java异常处理涉及到五个关键字，分别是：try、catch、finally、throw、throws。下面将骤一介绍，通过认识这五个关键字，掌握基本异常处理知识。 try：它里面放置可能引发异常的代码 catch：后面对应异常类型和一个代码块，用于表明该catch块用于处理这种类型的代码块，可以有多个catch块。 finally：主要用于回收在try块里打开的物力资源（如数据库连接、网络连接和磁盘文件），异常机制总是保证finally块总是被执行。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。 finally 关键字： 1234567public Integer test1() &#123; try &#123; return 1; &#125; finally &#123; return 2; &#125;&#125; 上面的示例：返回的结果为： 2 123456789public Integer test() &#123; try &#123; System.out.println("try&gt;&gt;&gt;&gt;&gt;&gt;&gt;"); return 1; &#125;finally &#123; System.out.println("finally&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;"); return 2; &#125;&#125; 上面的示例，返回的结果为： throw：用于抛出一个实际的异常，可以单独作为语句使用，抛出一个具体的异常对象。 throws：用在方法签名中，用于声明该方法可能抛出的异常。 throw与throws关键字的区别（1）throw关键字是用于方法体内部，用来抛出一个Throwable类型的异常。如果抛出了检查异常，则还应该在方法头部声明方法可能抛出的异常类型。该 方法的调用者也必须检查处理抛出的异常。如果所有方法都层层上抛获取的异常，最终JVM会进行处理，处理也很简单，就是打印异常消息和堆栈信息。如果抛出 的是Error或RuntimeException，则该方法的调用者可选择处理该异常。 （2）throws关键字用于方法体外部的方法声明部分，用来声明方法可能会抛出某些异常。仅当抛出了检查异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出，而不是囫囵吞枣一般在catch块中打印一下堆栈信息做个勉强处理。 1234public void test(int i) throws IllegalArgumentException&#123; if (i&lt;0) throw new IllegalArgumentException("参数异常");&#125; 说明：throws IllegalArgumentException 表示：此方法可能抛出 IllegalArgumentException 异常，至于抛不抛还要看方法中是否会捕捉到 IllegalArgumentException 异常。throw new IllegalArgumentException(“参数异常”); 表示 if 语句判断，是否会捕捉到 IllegalArgumentException 异常。 总结如下： throws语句用在方法声明后面，用来声明方法可能会抛出某些异常，由该方法的调用者来处理；throw语句用在方法体内，用来抛出一个Throwable类型的异常，由方法体内的语句处理。 throws主要是声明这个方法会抛出这种类型的异常，使它的调用者知道要捕获这个异常；throw是具体向外抛异常的动作，所以它是抛出一个异常实例。 throws表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某种异常。 异常在继承中注意事项 1.如果一个子类继承父类后,要重写父类继承过来的方法, 如果父类上没有声明编译时异常,子类方法不可以声明编译时异常。 2.如果一个子类继承父类后,要重写父类继承过来的方法,父类方法上有编译时异常声明,子类方法可以不用声明异常。 3.如果一个子类继承父类后,要重写父类继承过来的方法,父类方法上有编译时异常声明,子类方法不可以定义比父类方法范围大的异常。 附加：有return的情况下try catch finally的执行顺序 结论： 不管有木有出现异常，finally块中代码都会执行； 当try和catch中有return时，finally仍然会执行； finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样，返回的值都不会改变，任然是之前保存的值），所以函数返回值是在finally执行前确定的； finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值。 举例： 情况1：try{} catch(){}finally{} return;显然程序按顺序执行。 123456789101112public int test()&#123; int i = 1; try &#123; i++; &#125; catch (Exception e) &#123; e.printStackTrace(); ++i; &#125;finally &#123; System.out.println(i); // i = 2 &#125; return i; // i = 2 &#125; 情况2:try{ return; }catch(){} finally{} return; 程序执行try块中return之前（包括return语句中的表达式运算）代码； 再执行finally块，最后执行try中return; finally块之后的语句return，因为程序在try中已经return所以不再执行。 1234567891011121314public int test()&#123; int i = 1; try &#123; i++; return i; // i = 2 &#125; catch (Exception e) &#123; e.printStackTrace(); ++i; &#125;finally &#123; i +=3; System.out.println(i); // i = 5 &#125; return i; // 该语句未执行&#125; 情况3:try{ } catch(){return;} finally{} return; 程序先执行try，如果遇到异常执行catch块， 有异常：则执行catch中return之前（包括return语句中的表达式运算）代码，再执行finally语句中全部代码， 最后执行catch块中return. finally之后也就是4处的代码不再执行。 无异常：执行完try再finally再return. 1234567891011121314151617/** * 有异常 * @return */public int test()&#123; int i = 1; try &#123; int j = i/0; &#125; catch (Exception e) &#123; e.printStackTrace(); return i; // i = 1 &#125;finally &#123; i +=3; System.out.println(i); // i = 4 &#125; return i; // 该语句未执行&#125; 无异常的情况和情况1 的执行顺序一样。 情况4:try{ return; }catch(){} finally{return;} 程序执行try块中return之前（包括return语句中的表达式运算）代码； 再执行finally块，因为finally块中有return所以提前退出。 12345678910111213public int test()&#123; int i = 1; try &#123; i++; return i; //该语句未执行 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; i +=3; System.out.println(i); // i = 5 return i; // i = 5 &#125;&#125; 情况5:try{} catch(){return;}finally{return;} 程序执行catch块中return之前（包括return语句中的表达式运算）代码； 再执行finally块，因为finally块中有return所以提前退出。 12345678910111213public int test()&#123; int i = 1; try &#123; i++; &#125; catch (Exception e) &#123; e.printStackTrace(); return i; // 不管有没有异常该语句都不执行 &#125;finally &#123; i +=3; System.out.println(i); // i = 5 return i; // i = 5 &#125;&#125; 情况6:try{ return;}catch(){return;} finally{return;} 程序执行try块中return之前（包括return语句中的表达式运算）代码； 有异常：执行catch块中return之前（包括return语句中的表达式运算）代码； 则再执行finally块，因为finally块中有return所以提前退出。 无异常：则再执行finally块，因为finally块中有return所以提前退出。 123456789101112131415public int test()&#123; int i = 1; try &#123; i++; int j = i/0; return i; // 不管有没有异常该语句都不执行 &#125; catch (Exception e) &#123; e.printStackTrace(); //有异常的情况执行 return i; // 不管有没有异常该语句都不执行 &#125;finally &#123; i +=3; System.out.println(i); // i = 5 return i; // i = 5 &#125;&#125; 总结：任何执行try 或者catch中的return语句之前，都会先执行finally语句，如果finally存在的话。如果finally中有return语句，那么程序就return了，所以finally中的return是一定会被return的 final, finally, finalize的区别finally 是异常处理语句结构的一部分，表示总是执行.finalize 是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等. JVM不保证此方法总被调用. final：修饰符（关键字）&emsp;&emsp;如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract的，又被声明为final的。 &emsp;&emsp;将变量或方法声明为final，可以保证它们在使用中不被改变。 &emsp;&emsp;被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为final的方法也同样只能使用，不能重载 finally&emsp;&emsp;再异常处理时提供 finally 块来执行任何清除操作。如果抛出一个异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 finally 块（如果有的话）。 finalize：方法名。&emsp;&emsp;Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。 &emsp;&emsp;它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>Java基础</tag>
        <tag>Exception</tag>
        <tag>异常</tag>
      </tags>
  </entry>
</search>
