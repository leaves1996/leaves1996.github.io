---
title: Java面试题总结
copyright: true
comments: true
date: 2019-08-13 14:51:19
tags:
 - 面试题
 - JavaSE
 - Java基础
categories: Java面试题
description: 本文主要总结的是Java面试题总结。
sticky:
---
# Java面向对象

### 1.面向对象主要有四大特性：封装、抽象、继承和多态。

 - **封装**：在面向对象语言中，封装特性是由类来体现的，我们将现实生活中的一类实体定义成类，其中包括属性和行为（在Java中就是方法），就好像人类，可以具有name,sex,age等属性，同时也具有eat(),sleep()等行为，我们在行为中实现一定的功能，也可操作属性，这是面向对象的封装特性；

 - **抽象**：抽象就是将一类实体的共同特性抽象出来，封装在一个抽象类中，所以抽象在面向对象语言是由抽象类来体现的。比如鸟就是一个抽象实体，因为抽象实体并不是一个真正的对象，它的属性还不能完全描述一个对象，所以在语言中体现为抽象类不能实例化；

 - **继承**：继承就像是我们现实生活中的父子关系，儿子可以遗传父亲的一些特性，在面向对象语言中，就是一个类可以继承另一个类的一些特性，从而可以代码重用，其实继承体现的是is-a关系，父类同子类在本质上还是一类实体；

 - **多态**：多态就是通过传递给 父类对象 引用 不同的 子类对象 从而表现出不同的行为,父类类型引用指向子类对象就是多态。
  - 多态要实现的前提：
    - 1、必须要有继承关系，也就是必须有父子类关系。
    - 2、必须有父类类型引用指向子类对象关系。
    - 有方法重写，方法的重写的目的就是为了让多态更加的合理。

### 2.super()与this()的区别？
 - This（）：当前类的对象,super父类对象。
 - Super（）：在子类访问父类的成员和行为,必须受类继承规则的约束
 - 而this他代表当前对象,当然所有的资源都可以访问.
&emsp;&emsp;在构造函数中,如果第一行没有写super(),编译器会自动插入.但是如果父类没有不带参数的构造函数,或这个函数被私有化了(用private修饰).此时你必须加入对父类的实例化构造.而this就没有这个要求,因为它本身就进行实例化的构造.
&emsp;&emsp;而在方法中super和this使用的方法就差不多了.只不过super 要考虑是否能访问其父类的资源.

### 3.权限修饰符
访问权限修饰符|本类|同包下(普通类，子类)|不同包的子类|不同包的普通类
|:---------:|:---------:|:---------:|                                    
public|√|√|√|√ 
protected|√|√|√|×     
default|√|√|×|×         
private|√|×|×|× 

 - Public:不同包、同一包、类内都可用
 - Private：类内
 - Protected: 不同包的子类、同一包、类内都可用
 - 不写时:同一包内、类内

### 4.JAVA的事件委托机制和垃圾回收机制

&emsp;&emsp;java 事件委托机制的概念,一个源产生一个事件并将它送到一个或多个监听器那里。在这种方案中，监听器简单的等待，直到它收到一个事件。一旦事件被接受，监听器将处理这个事件，然后返回。

&emsp;&emsp;垃圾回收机制 垃圾收集是将分配给对象但不再使用的内存回收或释放的过程。如果一个对象没有指向它的引用或者其赋值为null,则次对象适合进行垃圾回收

### 5. Java 中如何跳出多重嵌套循环？

 - Java 中跳出多重嵌套循环的两种方式：
  - 方法一：定义一个标号，使用 break 加标号的方式
  - 方法二：使用全局变量终止循环

&emsp;&emsp;方法一，代码示例：
```java
myfor:for(int i = 0; i < 100; i++){
    for(int j = 0; j < 100; j++){
        System.out.println(j);
        if(j == 50){
            //跳出多重循环
            break myfor;
        }
    }
}
```

&emsp;&emsp;方法二，代码示例：
```java
boolean flag = true;
for(int i = 0; i < 100; i++){
    for(int j = 0; j < 100; j++){
        System.out.println(j);
        if(j == 50){
            //跳出多重循环
            flag = false;
            break;
        }
    }
}
```


